<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++为什么要引入auto</title>
      <link href="/posts/c76d.html"/>
      <url>/posts/c76d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要引入auto？"><a href="#1-为什么要引入auto？" class="headerlink" title="1. 为什么要引入auto？"></a>1. 为什么要引入auto？</h2><p>通常，在把表达式的值赋给变量时，我们需要在声明变量时准确地声明是什么类型。但是，有时候很难知道表达式到底是什么类型的，因此引入了auto类型说明符。auto会让编译器通过初始值来推算变量的类型。</p><h2 id="2-使用auto需要注意的是"><a href="#2-使用auto需要注意的是" class="headerlink" title="2. 使用auto需要注意的是"></a>2. 使用auto需要注意的是</h2><h3 id="auto定义的变量必须有初始值"><a href="#auto定义的变量必须有初始值" class="headerlink" title="auto定义的变量必须有初始值"></a><strong>auto定义的变量必须有初始值</strong></h3><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//由val1和val2相加的结果可以推断出item的类型 </span></code></pre><h3 id="一条auto声明语句只能有一个基本数据类型"><a href="#一条auto声明语句只能有一个基本数据类型" class="headerlink" title="一条auto声明语句只能有一个基本数据类型"></a><strong>一条auto声明语句只能有一个基本数据类型</strong></h3><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：i是整数，p是整型指针</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：sz和pi的类型不一致</span></code></pre><h3 id="编译器会改变推断结果使其更符合初始化规则"><a href="#编译器会改变推断结果使其更符合初始化规则" class="headerlink" title="编译器会改变推断结果使其更符合初始化规则"></a><strong>编译器会改变推断结果使其更符合初始化规则</strong></h3><p>比如，我们在使用一个引用时，其实就是使用该引用的对象。特别是引用被用作初始值时，真正参加初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">auto</span> a <span class="token operator">=</span> r<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a是一个整数（r是i的别名，而i是一个整数）</span></code></pre><h3 id="auto一般会忽略顶层const，保留底层const"><a href="#auto一般会忽略顶层const，保留底层const" class="headerlink" title="auto一般会忽略顶层const，保留底层const"></a><strong>auto一般会忽略顶层const，保留底层const</strong></h3><blockquote><p>顶层const表示指针本身是个常量<br>底层const表示表示指针所指的对象是个常量</p></blockquote><ol><li>比如当初始值指向一个常量指针时：</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//b是一个整数（ci的顶层特性被忽略掉了）</span>   <span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span>   <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//d是一个整型指针（整数的地址就是指向整数的指针）</span>   <span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></code></pre><ol start="2"><li>如果希望推断出的auto类型是一个顶层const，需要明确指出：</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ci的推演类型是int，f是const int</span></code></pre><ol start="3"><li>引用的类型设为auto，原来的初始化规则仍然适用</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//g是一个整型常量引用，绑定到ci</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能为非常量引用绑定字面值</span>   <span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：可以为常量引用绑定字面值</span></code></pre><p>   设置一个auto类型的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初值绑定一个引用，则此时的常量就不是顶层常量了。</p><ol start="4"><li>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">auto</span> k <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">&amp;</span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//k是整数，l是整型引用</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//m是整型常量的引用，p是指向整型常量的指针</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：i是整型int，而&amp;ci是整型常量const int</span></code></pre><h2 id="3-完整实例代码"><a href="#3-完整实例代码" class="headerlink" title="3. 完整实例代码"></a>3. 完整实例代码</h2><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//由val1和val2相加的结果可以推断出item的类型 </span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//正确：i是整数，p是整型指针</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：sz和pi的类型不一致</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//b是一个整数（ci的顶层特性被忽略掉了）</span><span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//d是一个整型指针（整数的地址就是指向整数的指针）</span><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span><span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ci的推演类型是int，f是const int</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//g是一个整型常量引用，绑定到ci</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：不能为非常量引用绑定字面值</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以为常量引用绑定字面值</span><span class="token keyword">auto</span> k <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">&amp;</span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//k是整数，l是整型引用</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//m是整型常量的引用，p是指向整型常量的指针</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：i是整型int，而&amp;ci是整型常量const int</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> C++ </tag>
            
            <tag> auto </tag>
            
            <tag> C++语言规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP传输协议</title>
      <link href="/posts/f5b7.html"/>
      <url>/posts/f5b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再向服务器发一个确认ACK K+1</li></ul><p>这就完了三次握手，但是这三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="./1.gif" data-original="https://tva4.sinaimg.cn/large/005JD0Ejgy1gctbsm9xt8j30c406ddfy.jpg" alt="socket中发送的TCP三次握手"></p><p><strong>socket中发送的TCP三次握手</strong></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求并向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="./1.gif" data-original="https://tva4.sinaimg.cn/large/005JD0Ejgy1gctbtt46saj30a606d74c.jpg" alt="socket中发送的TCP四次握手"></p><p><strong>socket中发送的TCP四次握手</strong></p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> TCP握手协议 </tag>
            
            <tag> 客户端/服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket函数</title>
      <link href="/posts/16d9.html"/>
      <url>/posts/16d9.html</url>
      
        <content type="html"><![CDATA[<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用<code>bind()</code>函数，否则就当调用<code>connect()</code>、<code>listen()</code>时系统会自动随机分配一个端口。</p><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过<code>socket()</code>函数创建了，唯一标识一个socket。<code>bind()</code>函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p></li></ul><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">struct</span> sockaddr_in <span class="token punctuation">{</span>    sa_family_t    sin_family<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* address family: AF_INET */</span>    in_port_t      sin_port<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* port in network byte order */</span>    <span class="token keyword">struct</span> in_addr sin_addr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* internet address */</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Internet address. */</span>  <span class="token keyword">struct</span> in_addr <span class="token punctuation">{</span>    uint32_t       s_addr<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* address in network byte order */</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>  ipv6对应的是：</p><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">struct</span> sockaddr_in6 <span class="token punctuation">{</span>     sa_family_t     sin6_family<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* AF_INET6 */</span>     in_port_t       sin6_port<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* port number */</span>     uint32_t        sin6_flowinfo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* IPv6 flow information */</span>     <span class="token keyword">struct</span> in6_addr sin6_addr<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* IPv6 address */</span>     uint32_t        sin6_scope_id<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Scope ID (new in 2.4) */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> in6_addr <span class="token punctuation">{</span>     <span class="token keyword">unsigned</span> <span class="token keyword">char</span>   s6_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* IPv6 address */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>  Unix域对应的是：</p><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token macro property">#<span class="token directive keyword">define</span> UNIX_PATH_MAX    108</span>  <span class="token keyword">struct</span> sockaddr_un <span class="token punctuation">{</span>     sa_family_t sun_family<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* AF_UNIX */</span>     <span class="token keyword">char</span>        sun_path<span class="token punctuation">[</span>UNIX_PATH_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* pathname */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>addrlen：对应的是地址的长度。</li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用<code>bind()</code>，而客户端就不会调用，而是在<code>connect()</code>时由系统随机生成一个。</p><blockquote><p>网络字节序与主机字节序<br><strong>主机字节序</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br><strong>网络字节序</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。<strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br><strong>所以</strong>：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p></blockquote><h2 id="listen函数、connect函数"><a href="#listen函数、connect函数" class="headerlink" title="listen函数、connect函数"></a>listen函数、connect函数</h2><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个socket，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>TCP服务器端依次调用<code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的socket地址了。TCP客户端依次调用<code>socket()</code>、<code>connect()</code>之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用<code>accept()</code>函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p><strong>注意</strong>：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个<strong>已连接socket描述字</strong>，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p><h2 id="read函数、write函数"><a href="#read函数、write函数" class="headerlink" title="read函数、write函数"></a>read函数、write函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li><code>read()</code>/<code>write()</code></li><li><code>recv()</code>/<code>send()</code></li><li><code>readv()</code>/<code>writev()</code></li><li><code>recvmsg()</code>/<code>sendmsg()</code></li><li><code>recvfrom()</code>/<code>sendto()</code></li></ul><p>它们的声明如下：</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>ssize_t <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>dest_addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>                        <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recvmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h2 id="使用Socket-API建立简易TCP服务器"><a href="#使用Socket-API建立简易TCP服务器" class="headerlink" title="使用Socket API建立简易TCP服务器"></a>使用Socket API建立简易TCP服务器</h2><ol><li>建立一个Socket</li><li>绑定接受客户端连接的端口 bind</li><li>监听网络端口 listen</li><li>等待接收客户端连接 accept</li><li>向客户端发送一条数据 send</li><li>关闭Socket closesocket</li></ol><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> WIN32_LEAN_AND_MEAN</span><span class="token macro property">#<span class="token directive keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;WinSock2.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//启动Windows Socket 2.x 环境</span>    WORD ver <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WSADATA dat<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span>ver<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">// 1 建立一个Socket 套接字</span>    SOCKET _sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span>IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>INVALID_SOCKET <span class="token operator">==</span> _sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to new a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: New a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>           <span class="token comment" spellcheck="true">//IPv4的网络套接字 //面向数据流 //TCP协议</span>    <span class="token comment" spellcheck="true">// 2 bind 绑定接受客户端连接的端口 </span>    sockaddr_in _sin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">4567</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//host to net unsigned short</span>    _sin<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//net_addr("127.0.0.1");</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> <span class="token function">bind</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_sin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:绑定网络端口失败...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"绑定网络端口成功...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3 listen 监听网络端口 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> <span class="token function">listen</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:监听网络端口失败...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"监听网络端口成功...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 4 accept等待接收客户端连接 </span>    sockaddr_in clientAddr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nAddrLen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    SOCKET _cSock <span class="token operator">=</span> INVALID_SOCKET<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> msgBuf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, I'm Server."</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        _cSock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientAddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nAddrLen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> _cSock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:接收到无效客户端SOCKET...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"新客户端加入：IP = %s \n"</span><span class="token punctuation">,</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>clientAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 5 send 向客户端发送一条数据 </span>        <span class="token function">send</span><span class="token punctuation">(</span>_cSock<span class="token punctuation">,</span> msgBuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msgBuf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 6 关闭套接字Socket closesocket</span>    <span class="token function">closesocket</span><span class="token punctuation">(</span>_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//清除windows socket 环境</span>    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="使用Socket-API建立简易TCP客户端"><a href="#使用Socket-API建立简易TCP客户端" class="headerlink" title="使用Socket API建立简易TCP客户端"></a>使用Socket API建立简易TCP客户端</h2><ol><li>建立一个Socket</li><li>connect 连接服务器</li><li>recv 接收服务器信息</li><li>关闭Socket closesocket</li></ol><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> WIN32_LEAN_AND_MEAN</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;WinSock2.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//启动Windows Socket 2.x 环境</span>    WORD ver <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WSADATA dat<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span>ver<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//-- 使用Socket API建立简易TCP客服端</span>    <span class="token comment" spellcheck="true">// 1 建立一个Socket</span>    SOCKET _sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>INVALID_SOCKET <span class="token operator">==</span> _sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to new a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: New a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2 connect 连接服务器 </span>    sockaddr_in _sin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">4567</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_sin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to connect to Server...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: Connect to Server...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3 recv 接收服务器信息</span>    <span class="token keyword">char</span> recvBuf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nlen <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> recvBuf<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nlen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive Data: %s \n"</span><span class="token punctuation">,</span> recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 4 关闭Socket closesocket</span>    <span class="token function">closesocket</span><span class="token punctuation">(</span>_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//清除windows socket 环境</span>    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="./1.gif" data-original="https://tvax4.sinaimg.cn/large/005JD0Ejgy1gcdoxi7loej30pv0fpdgm.jpg" alt="服务端"></p><p><strong>服务端</strong></p><p><img src="./1.gif" data-original="https://tvax3.sinaimg.cn/large/005JD0Ejgy1gcdoxy5g1bj30qb0fgq3l.jpg" alt="客户端"></p><p><strong>客户端</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> socket函数 </tag>
            
            <tag> TCP客户端/服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/posts/b54b.html"/>
      <url>/posts/b54b.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​     Linux 具有<a href="https://baike.baidu.com/item/开放源码/7176422" target="_blank" rel="noopener">开放源码</a>、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。这些特点使得Linux成为开发路由交换设备的理想开发平台。</p><h3 id="1-tar打包"><a href="#1-tar打包" class="headerlink" title="1. tar打包"></a>1. tar打包</h3><p>Linux tar命令用于备份文件。tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><p>语法如下：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F ][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]</code></pre></blockquote><p>参数：</p><ul><li>-A或–catenate 新增文件到已存在的备份文件。</li><li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li><li>-B或–read-full-records 读取数据时重设区块大小。</li><li>-c或–create 建立新的备份文件。</li><li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li><li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li><li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li><li>-g或–listed-incremental 处理GNU格式的大量备份。</li><li>-G或–incremental 处理旧的GNU格式的大量备份。</li><li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li><li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li><li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li><li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li><li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li><li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li><li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li><li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li><li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li><li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li><li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li><li>-p或–same-permissions 用原来的文件权限还原文件。</li><li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li><li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li><li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li><li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li><li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li><li>-t或–list 列出备份文件的内容。</li><li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li><li>-u或–update 仅置换较备份文件内的文件更新的文件。</li><li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li><li>-v或–verbose 显示指令执行过程。</li><li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li><li>-w或–interactive 遭遇问题时先询问用户。</li><li>-W或–verify 写入备份文件后，确认文件正确无误。</li><li>-x或–extract或–get 从备份文件中还原文件。</li><li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li><li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li><li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li><li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li><li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li><li>–atime-preserve 不变更文件的存取时间。</li><li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li><li>–checkpoint 读取备份文件时列出目录名称。</li><li>–concatenate 此参数的效果和指定”-A”参数相同。</li><li>–confirmation 此参数的效果和指定”-w”参数相同。</li><li>–delete 从备份文件中删除指定的文件。</li><li>–exclude=&lt;范本样式&gt; 排除符合范本样式的文件。</li><li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li><li>–help 在线帮助。</li><li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li><li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li><li>–newer-mtime 只保存更改过的文件。</li><li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li><li>–null 从null设备读取文件名称。</li><li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li><li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li><li>–posix 将数据写入备份文件时使用POSIX格式。</li><li>–preserve 此参数的效果和指定”-ps”参数相同。</li><li>–preserve-order 此参数的效果和指定”-A”参数相同。</li><li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li><li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li><li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li><li>–remove-files 文件加入备份文件后，就将其删除。</li><li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li><li>–same-owner 尝试以相同的文件拥有者还原文件。</li><li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li><li>–totals 备份文件建立后，列出文件大小。</li><li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li><li>–version 显示版本信息。</li><li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li></ul><p>常用案例：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">tar -czvf test.tar.gz a.c   //压缩a.c文件为test.tar.gztar -tzvf test.tar.gz       //列出压缩文件内容tar -xzvf test.tar.gz       //解压文件</code></pre></blockquote><h3 id="2-find查找"><a href="#2-find查找" class="headerlink" title="2. find查找"></a>2. find查找</h3><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>语法：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></pre></blockquote><p>参数说明：</p><blockquote><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2</p></blockquote><p>常用命令案例：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">//将当前目录及其子目录下所有延伸档名是 c 的文件列出来find . -name "*.c"//将当前目录其其下子目录中所有一般文件列出find . -type f//将当前目录及其子目录下所有最近 20 天内更新过的文件列出find . -ctime -20//查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们find /var/log -type f -mtime +7 -ok rm {} \;//查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件find . -type f -perm 644 -exec ls -l {} \;//为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径find / -type f -size 0 -exec ls -l {} \;</code></pre></blockquote><p>#####3. sz下载，rz上传</p><p>rz，sz是<code>Linux/Unix</code>同<code>Windows</code>进行<code>ZModem</code>文件传输的命令行工具。<br>优点就是不用再开一个sftp工具登录上去上传下载文件。</p><p>sz：将选定的文件发送（send）到本地机器<br>rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器</p><p>安装命令：</p><blockquote><p>yum install lrzsz</p></blockquote><p>从服务端发送文件到客户端：</p><blockquote><p>sz filename</p></blockquote><p>从客户端上传文件到服务端：</p><p>rz</p><p>在弹出的框中选择文件，上传文件的用户和组是当前登录的用户</p><p><code>SecureCRT</code>设置默认路径：</p><p>Options -&gt; Session Options -&gt; Terminal -&gt; Xmodem/Zmodem -&gt;Directories</p><p><code>Xshell</code>设置默认路径：</p><p>右键会话 -&gt; 属性 -&gt; ZMODEM -&gt; 接收文件夹</p><h3 id="3-mv命令"><a href="#3-mv命令" class="headerlink" title="3. mv命令"></a>3. mv命令</h3><p>mv 命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>语法：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">mv [options] source destmv [options] source... directory</code></pre></blockquote><p>参数说明：</p><ul><li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li></ul><p>参数设置和运行结果：</p><table><thead><tr><th align="left">命令格式</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">mv 文件名 文件名</td><td align="left">将源文件名改为目标文件名</td></tr><tr><td align="left">mv 文件名 目录名</td><td align="left">将文件移动到目标目录</td></tr><tr><td align="left">mv 目录名 目录名</td><td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td align="left">mv 目录名 文件名</td><td align="left">出错</td></tr></tbody></table><p>命令案例：</p><blockquote><p>mv a b //将文件a更名为b</p><p>mv info/ logs //将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p><p>mv /home/img/* . //将/home/img下的所有文件和目录移到当前目录下</p></blockquote><p>注意：</p><blockquote><p>mv /home/a.txt /home/b.txt //目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名。</p><p>//目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动。</p><p>mv /home/a.txt /home/test/ 或者 mv /home/a.txt /home/test</p><p>mv /home/a.txt /home/test/b.txt //目标目录与原目录一致, 指定了新文件名，效果就是：移动 + 重命名。</p></blockquote><h3 id="4-Linux开发工具"><a href="#4-Linux开发工具" class="headerlink" title="4. Linux开发工具"></a>4. Linux开发工具</h3><p>Linux已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在Linux的帮助下，技术的变革速度超出了人们的想象，Linux开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习Linux开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着Linux的发展，大量适用于Linux的开发工具也不断成熟。</p><p>容器</p><p> 放眼现实，现在已经是容器的时代了。容器既极其容易部署，又可以方便地构建开发环境。如果针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。</p><p>版本控制工具</p><p>如果正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。</p><p>文本编辑器</p><p>如果没有文本编辑器，在Linux上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。</p><p>集成开发环境</p><p>集成开发环境(Integrated Developmemt Envimnment，<a href="https://baike.baidu.com/item/IDE/8232086" target="_blank" rel="noopener">IDE</a>) 是包含一整套全面的工具、可以实现一站式功能的开发环境。</p><p>文本比较工具</p><p>有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本(例如有一个经过编译，而另一个没有)。这种情况下，肯定不想要凭借肉眼来找出差异，而是想要使用像<a href="https://baike.baidu.com/item/Med/8237994" target="_blank" rel="noopener">Med</a>这样的工具。 </p><p>如果有错的话，请给我留言，我会及时更新,谢谢合作……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> auto </tag>
            
            <tag> 开源代码 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么写文章</title>
      <link href="/posts/1513.html"/>
      <url>/posts/1513.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 有时候自己写<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>文章的时候,老是记不住<a href="https://baike.baidu.com/item/markdown?fr=aladdin" target="_blank" rel="noopener">Markdown</a>文档的语法或者怎么新建文章，还有<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter </a>选项怎么去用，所以呢！我就准备自己写一篇文章去记录这些，以免每次写文章都得去百度一大堆东西,本文章不定期更新….</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="新建文章模板修改"><a href="#新建文章模板修改" class="headerlink" title="新建文章模板修改"></a>新建文章模板修改</h3><p> 首先为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class=" language-json"><code class="language-json">title<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span>date<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> date <span class="token punctuation">}</span><span class="token punctuation">}</span>author<span class="token operator">:</span> img<span class="token operator">:</span> coverImg<span class="token operator">:</span> top<span class="token operator">:</span> <span class="token boolean">false</span>cover<span class="token operator">:</span> <span class="token boolean">false</span>toc<span class="token operator">:</span> <span class="token boolean">true</span>mathjax<span class="token operator">:</span> <span class="token boolean">false</span>password<span class="token operator">:</span>summary<span class="token operator">:</span>tags<span class="token operator">:</span>categories<span class="token operator">:</span>---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了</p><h3 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h3><h4 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h4><p><code>Front-matte1r</code>选项中的所有内容均为非必填的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><p><img src="./1.gif" data-original="https://cdn.jsdelivr.net/gh/baifeng66/picgophots/images/fm1.png" alt=""></p><p><img src="./1.gif" data-original="https://cdn.jsdelivr.net/gh/baifeng66/picgophots/images/fm2.png" alt=""></p><blockquote><p>注意:</p><ol><li>如果<code>img</code>属性不填写的话，文章特色图会根据文章标题的<code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别<code>id</code>是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code>加密的 <code>password</code> 的值，还需要在主题的<code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="https://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 <code>front-matter</code> 中指定 <code>reprintPolicy</code>来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 Front-matter 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-yml"><code class="language-yml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yml"><code class="language-yml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="一、参考文档"><a href="#一、参考文档" class="headerlink" title="一、参考文档"></a>一、参考文档</h4><blockquote><p><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown 中文版语法说明</a></p><p><a href="https://blog.csdn.net/u014061630/article/details/81359144" target="_blank" rel="noopener">Markdown语法图文全面详解(10分钟学会)</a></p><p><a href="https://blog.csdn.net/sanallen/article/details/92081911" target="_blank" rel="noopener">Markdown文档编写指南</a></p><p><a href="https://sunhwee.gitee.io/posts/a927e90e.html#toc-heading-1" target="_blank" rel="noopener">Markdown Emoji表情语法速查表</a></p><p><a href="https://sunhwee.gitee.io/posts/7e1e06e9.html" target="_blank" rel="noopener">Markdown 插入图片或者视频</a></p></blockquote><h4 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h4><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><p>   注：# 后面保持空格</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># h1</span><span class="token comment" spellcheck="true">## h2</span><span class="token comment" spellcheck="true">### h3</span><span class="token comment" spellcheck="true">#### h4</span><span class="token comment" spellcheck="true">##### h5</span><span class="token comment" spellcheck="true">###### h6</span></code></pre><h5 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h5><p>Markdown划分段落非常简单，就是在段落前后保留一个空行即可，例如：</p><pre><code>这是第一个段落内容这是第二个段落内容</code></pre><p>效果如下：</p><p>这是第一个段落内容</p><p>这是第二个段落内容</p><h5 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h5><p>如果我们需要对一段内容进行强调显示时，Markdown提供了一个特殊符号&gt;(&gt;和内容之前需要空一个空格)用于段落区块引用：</p><pre><code>&gt;这是一段引用段落，将会被高亮显示</code></pre><p>效果如下：</p><blockquote><p>这是一段引用段落，将会被高亮显示</p></blockquote><p>Markdown支持同时强调引用多个段落，可以按照如下方式书写</p><pre><code>&gt; 这是一段引用段落，将会被高亮显示&gt;&gt; 这也是一段引用段落，也会被高亮显示</code></pre><blockquote><p>这是一段引用段落，将会被高亮显示</p><p>这也是一段引用段落，也会被高亮显示</p></blockquote><h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><pre><code>[超链接显示文字](http://www.baidu.com "超链接title")</code></pre><p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="超链接title">超链接显示文字</a></p><p>提示：超链接title为浮动提示文字，一般情况可以不填写</p><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><pre><code>![百度logo](https://www.baidu.com/img/bd_logo1.png?where=super)</code></pre><p><img src="./1.gif" data-original="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度logo"></p><blockquote><p>图片和超链接的唯一区别就是在最前方添加一个感叹号</p></blockquote><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表使用<em>、+、-标识，但是一般使用</em>来标识无序列表</p><p>单级列表从最左开始(适用于无序列表)</p><pre><code>* 无序列表项* 无序列表项* 无序列表项</code></pre><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项</li></ul><p>Markdown支持多级列表嵌套，但是建议一般不使用超过两级列表，另外建议两级列表从缩进3个空格开始(适用于无序列表)，如下所示:</p><pre><code>   * 无序列表项      * 第二层列表项      * 第二层列表项   * 无序列表项   * 无序列表项</code></pre><ul><li>无序列表项<ul><li>第二层列表项</li><li>第二层列表项</li></ul></li><li>无序列表项</li><li>无序列表项</li></ul><p>有序列表</p><p>有序列表使用<font color="red">数字 </font>.标识</p><pre><code>1. 有序列表项12. 有序列表项23. 有序列表项3</code></pre><ol><li>有序列表项1</li><li>有序列表项2</li><li>有序列表项3</li></ol><pre><code>   1. 有序列表项1      1. 有序列表项11      2. 有序列表项12   2. 有序列表项3</code></pre><ol><li>有序列表项1<ol><li>有序列表项11</li><li>有序列表项12</li></ol></li><li>有序列表项3</li></ol><h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><pre><code>***---</code></pre><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><pre><code>*这里是文字*_这里是文字_**这里是文字*****这里是文字***~~这里是文字~~</code></pre><p><em>这里是文字</em></p><p><em>这里是文字</em></p><p><strong>这里是文字</strong></p><p><strong><em>这里是文字</em></strong></p><p><del>这里是文字</del></p><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><h6 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h6><p>使用单个反引号进行包裹行内代码，例如 <code>var x = 10</code></p><h6 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h6><p>可以通过三个反引号将代码包裹起来，反引号单独占一行，多一行单引号后面可以需要添加编程语言，详细的编程语言见<a href="https://pygments.org/languages/" target="_blank" rel="noopener">http://pygments.org/languages/</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span>func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><pre><code>| 表头 | 表头 | 表头 || ---- | ---- | ---- || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 |</code></pre><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr></tbody></table><p>如果有错的话，请给我留言，我会及时更新,谢谢合作…… </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> VS code </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dream</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>不是每个人都应该像我这样去建造一座水晶大教堂，但是每个人都应该拥有自己的梦想，设计自己的梦想，追求自己的梦想，实现自己的梦想。梦想是生命的灵魂，是心灵的灯塔，是引导人走向成功的信仰。有了崇高的梦想，只要矢志不渝地追求，梦想就会成为现实，奋斗就会变成壮举，生命就会创造奇迹。——罗伯·舒乐</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 梦想 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
