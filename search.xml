<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL常见用法</title>
      <link href="/posts/58fb.html"/>
      <url>/posts/58fb.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL常见用法"><a href="#STL常见用法" class="headerlink" title="STL常见用法"></a>STL常见用法</h1><h3 id="1、选择C-刷算法的理由"><a href="#1、选择C-刷算法的理由" class="headerlink" title="1、选择C++刷算法的理由"></a>1、选择C++刷算法的理由</h3><ul><li>1.C++速度快（C不是更快么，java太慢了）</li><li>2.C++有STL（什么是STL）——使用很方便的类库</li><li>3.如何使用STL进行高效刷算法</li><li>4.好处：刷算法，学习成本极低</li><li>5.如何从C到C++（仅基础语法到刷算法程度）</li></ul><h3 id="2、输入输出"><a href="#2、输入输出" class="headerlink" title="2、输入输出"></a>2、输入输出</h3><p>C++保留了C的scanf和printf，增加了额外的cin与cout</p><p>例子</p><h5 id="2-1-C程序中输入输出"><a href="#2-1-C程序中输入输出" class="headerlink" title="2.1.C程序中输入输出"></a>2.1.C程序中输入输出</h5><p>c</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-2-C-输入输出"><a href="#2-2-C-输入输出" class="headerlink" title="2.2.C++输入输出"></a>2.2.C++输入输出</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">;</span></code></pre><h5 id="2-3-连续输入输出变量"><a href="#2-3-连续输入输出变量" class="headerlink" title="2.3.连续输入输出变量"></a>2.3.连续输入输出变量</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token operator">>></span>c<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>c<span class="token punctuation">;</span></code></pre><h5 id="2-4-优雅地换行"><a href="#2-4-优雅地换行" class="headerlink" title="2.4.优雅地换行"></a>2.4.优雅地换行</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>好处：</p><p>1.少写了很多东西</p><p>2.连续输入输出变量</p><p>3.换行优雅</p><pre><code>注意：cin、cout比scanf、printf慢，有时候刷算法超时，可能因为使用了cin、cout输入输出的数量(&gt;1000)特别多，刷算法用cin，cout容易超时</code></pre><h3 id="3、STL-Standard-Template-Library-与algorithm头文件"><a href="#3、STL-Standard-Template-Library-与algorithm头文件" class="headerlink" title="3、STL(Standard Template Library)与algorithm头文件"></a>3、STL(Standard Template Library)与algorithm头文件</h3><p>STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。</p><p>algorithm是对容器继承的一些算法函数，辅助刷算法题</p><p>sort函数</p><p>概念：迭代器——理解为指针</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">7</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、STL——string"><a href="#4、STL——string" class="headerlink" title="4、STL——string(*)"></a>4、STL——string(*)</h3><p>概念：相当于char*的封装，理解为字符串</p><h5 id="4-1-简单使用"><a href="#4-1-简单使用" class="headerlink" title="4.1.简单使用"></a>4.1.简单使用</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**C中定义字符串以及打印*/</span><span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token operator">=</span><span class="token string">"asdkajbf"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>ch<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**C++中*/</span>string s<span class="token operator">=</span><span class="token string">"ssadaffw"</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><h5 id="4-2-获取一行字符串"><a href="#4-2-获取一行字符串" class="headerlink" title="4.2.获取一行字符串"></a>4.2.获取一行字符串</h5><p>我想获取一行字符串</p><pre><code>hello world</code></pre><p>C中：</p><p>c</p><pre class=" language-c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.仅获取一个单词，空格结束 2.ch[100]得设置初始大小</span></code></pre><p>C++中：</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token punctuation">;</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取一行数据</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span></code></pre><h5 id="4-3-运算符"><a href="#4-3-运算符" class="headerlink" title="4.3.+=运算符"></a>4.3.+=运算符</h5><p>+=对于字符串，字符有效，数字会转为asc码</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token punctuation">;</span>s<span class="token operator">+</span><span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>s<span class="token operator">+</span><span class="token operator">=</span><span class="token string">" world"</span><span class="token punctuation">;</span>s<span class="token operator">+</span><span class="token operator">=</span><span class="token string">'5'</span><span class="token punctuation">;</span>s<span class="token operator">+</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10对应的asc码是换行</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//想把a加入字符串</span>s<span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span></code></pre><h5 id="4-4-排序（使用algorithm）"><a href="#4-4-排序（使用algorithm）" class="headerlink" title="4.4.排序（使用algorithm）"></a>4.4.排序（使用algorithm）</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token operator">=</span><span class="token string">"5418340"</span><span class="token punctuation">;</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span></code></pre><h5 id="4-5-erase函数"><a href="#4-5-erase函数" class="headerlink" title="4.5.erase函数"></a>4.5.erase函数</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**begin是头迭代器，end是尾迭代器*/</span>string s<span class="token operator">=</span><span class="token string">"5418340"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除第一个</span>s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">--</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除最后一个</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span></code></pre><h5 id="4-6-substr函数"><a href="#4-6-substr函数" class="headerlink" title="4.6.substr函数"></a>4.6.substr函数</h5><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**begin是头迭代器，end是尾迭代器*/</span>string s<span class="token operator">=</span><span class="token string">"5418340"</span><span class="token punctuation">;</span>s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取418,取索引为1，往后截断3个</span>s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//索引为1，截断到最后</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span></code></pre><h5 id="4-7-循环-3种"><a href="#4-7-循环-3种" class="headerlink" title="4.7.循环(3种)"></a>4.7.循环(3种)</h5><p>1.for循环</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token operator">=</span><span class="token string">"5418340"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>2.迭代器</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>string<span class="token operator">::</span>iterator it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token punctuation">;</span></code></pre><p>3.迭代器化简</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token punctuation">;</span></code></pre><p>4.利用C++ 11新特性for循环</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>s<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token punctuation">;</span></code></pre><h3 id="5、STL——vector"><a href="#5、STL——vector" class="headerlink" title="5、STL——vector(*)"></a>5、STL——vector(*)</h3><p>概念：vector相当于数组，模板类型相当于存放的内容</p><p>1.vector构造</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个空vector</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个4个大小的vector，初始为0</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个4个大小的vector，初始为6</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个vector，数字为1,2，3,4,5</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>v3<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token punctuation">;</span></code></pre><p>2.用at或者[]获取元素</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取索引为1的</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取索引为2的</span></code></pre><p>3.方法</p><ul><li>push_back追加内容</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>v<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token punctuation">;</span></code></pre><ul><li>resize进行重置大小</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不赋值默认为0</span></code></pre><ul><li>erase删除元素，复杂度为O(n)</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除第一个元素</span>v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">--</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除最后一个元素</span></code></pre><ul><li>获取第一个元素，获取最后一个元素</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**获取第一个元素*/</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**获取最后一个元素*/</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//size是获取大小</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token operator">--</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4.排序</p><p>第三个参数为比较器，不写默认为less()</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>less<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从小到大</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从大到小排序</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>v<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token punctuation">;</span></code></pre><p>5.循环</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//for循环</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//迭代器循环</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//迭代器简化循环</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>v<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//c++11新特性</span></code></pre><h3 id="6、STL——stack"><a href="#6、STL——stack" class="headerlink" title="6、STL——stack(*)"></a>6、STL——stack(*)</h3><p>概念：栈</p><ul><li>构造</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span></code></pre><ul><li>push、pop、size、empty</li><li>push 入栈一个元素</li><li>pop 出栈一个元素，pop无返回值</li><li>top 取栈顶元素</li><li>size 查看元素个数</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><ul><li>进制转换(十进制转二进制)</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">itob</span><span class="token punctuation">(</span><span class="token keyword">int</span> decimal<span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>decimal<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>decimal<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        decimal<span class="token operator">/</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token operator">=</span>res<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>逆序单词（拓展sstream，stoi，itoa）</li></ul><p>输入一行字符串，将字符串逆序打印</p><p>输入：hello world my name is steve yu</p><p>输出：yu steve is name my world hello</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string str<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span>string<span class="token operator">></span> s<span class="token punctuation">;</span>    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    stringstream ss<span class="token punctuation">;</span>    ss<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ss<span class="token operator">>></span>str<span class="token punctuation">)</span>        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>字符串转数字</li></ul><p>方法1:</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"> string s<span class="token operator">=</span><span class="token string">"1234"</span><span class="token punctuation">;</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> stringstream ss<span class="token punctuation">;</span> ss<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span> ss<span class="token operator">>></span>i<span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span></code></pre><p>方法2:</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">string s<span class="token operator">=</span><span class="token string">"1234"</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span></code></pre><ul><li>数字转字符串</li></ul><p>方法1:</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">;</span>string out<span class="token punctuation">;</span>stringstream ss<span class="token punctuation">;</span>ss<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">;</span>ss<span class="token operator">>></span>out<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>out<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>方法2:(c++ 11)</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">to_string</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><h3 id="7、STL——queue"><a href="#7、STL——queue" class="headerlink" title="7、STL——queue"></a>7、STL——queue</h3><p>概念：队列</p><ul><li>构造</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span></code></pre><ul><li>push、back</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><h3 id="8、STL——map-unordered-map-pair"><a href="#8、STL——map-unordered-map-pair" class="headerlink" title="8、STL——map(unordered_map pair)"></a>8、STL——map(unordered_map pair)</h3><p>概念：映射（map为树状表，unorderedmap为哈希表）</p><ul><li>map</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有序的，树状结构（底层）</span>m<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>unordered_map</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//无序的，哈希结构（底层）</span>m<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>pair的用法(map转成vector进行排序)</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">,</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>first<span class="token operator">></span>b<span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//无序的，哈希结构（底层）</span>    m<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">v</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="9、set-unordered-set"><a href="#9、set-unordered-set" class="headerlink" title="9、set(unordered_set)"></a>9、set(unordered_set)</h3><p>概念：集合</p><ul><li>应用计数、去重</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//树状结构，有序</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//哈希结构，无序，快</span>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>s<span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>tmp<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><h3 id="10、STL——deque"><a href="#10、STL——deque" class="headerlink" title="10、STL——deque"></a>10、STL——deque</h3><p>概念：双端队列</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> d<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4 9 1 2</span>d<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>d<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>tmp<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>d<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>d<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><ul><li>排序</li></ul><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="11、STL——list"><a href="#11、STL——list" class="headerlink" title="11、STL——list"></a>11、STL——list</h3><p>概念：双向链表</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> li<span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">emplace_front</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">++</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> tmp<span class="token operator">:</span>li<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>tmp<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>li<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> STL各种函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统面试题</title>
      <link href="/posts/abdc.html"/>
      <url>/posts/abdc.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、操作系统有哪些调度方法？</strong></p><p>1、先来先服务调度算法<br>2、短作业(进程)优先调度算法<br>3、高优先权优先调度算法<br>4、高响应比优先调度算法<br>5、时间片轮转法<br>6、多级反馈队列调度算法</p><p><strong>2、请你说一说进程和线程区别</strong></p><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。<br>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）<br>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。<br>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。<br>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。<br>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。<br>7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。<br>8、进程适应于多核、多机分布；线程适用于多核。</p><p><strong>3、进程间通信</strong></p><p>网络,共享内存,消息队列,管道,信号量<br>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><p>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p><p>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p><p>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p><p><strong>4、线程间同步</strong></p><p>互斥锁,信号量,条件变量</p><p>    使用临界区对象。拥有临界区对象的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区对象的线程放弃临界区对象为止【只用于同一进程】</p><p><strong>信号量</strong></p><p>是用来解决进程/线程之间的同步和互斥问题的一种通信机制，是用来保证两个或多个关键代码不被并发调用。</p><p>信号量（Saphore）由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。信号量S&gt;=0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个资源，因此S的值减1；当S&lt;0时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。而执行一个V操作意味着释放一个资源，因此S的值加1；若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</p><p>信号量是选择睡眠的方式来对共享工作停止访问的。</p><p><strong>也就是说信号量通过PV操作同步解决了进程/线程对临界资源利用的冲突问题；</strong></p><p><strong>互斥锁</strong></p><p>互斥锁同样也是对线程间（不能对进程）同步和互斥的一种另一种机制。</p><p>互斥锁更多的是强调对共享资源的锁定作用，当一个线程占用了当前共享资源，使用互斥锁将其lock住之后，其他线程就无法访问，必须等到unlock之后，其他线程才能利用共享资源里面的内容；</p><p>互斥锁是选择睡眠的方式来对共享工作停止访问的。</p><p><strong>也就是说互斥锁通过对共享资源的锁定和互斥解决利用资源冲突问题；</strong></p><p><strong>自旋锁</strong></p><p>是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><p><strong>5、死锁</strong></p><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p><strong>产生死锁的原因？</strong><br>可归结为如下两点：</p><p>①竞争资源</p><p>系统中的资源可以分为两类：<br>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；<br>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。<br>产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）<br>产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁<br>② 进程间推进顺序非法</p><p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁<br>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁<br><strong>死锁产生的4个必要条件？</strong></p><p>①互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p><p>②请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>③不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>④环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p><p><strong>解决死锁的基本方法</strong></p><p>①预防死锁</p><p>②避免死锁<br>银行家算法【在动态分配资源的过程中，银行家算法防止系统进入不安全状态，从而避免死锁】<br>银行家算法：</p><p>    当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</p><p>    当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。</p><p>安全序列：是指系统能按某种进程推进顺序（P1, P2, P3, …, Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列【银行家算法的核心就是找到一个安全序列】。<br>系统安全状态 ：如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态<br>③检测死锁<br>根据死锁定理：S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件称为死锁定理。<br>④解除死锁<br>1、资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程。（但应该防止被挂起的进程长时间得不到资源）；</p><p>2、撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；</p><p>3、进程回退：让一个或多个进程回退到足以避免死锁的地步。【进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。】</p><p><strong>6、进程有哪几种状态？</strong></p><p>①新建：进程开始创建状态<br>②运行：该进程的指令代码正在执行<br>③等待：进程正在等待某个时间，比如I/O完成或收到信号<br>④就绪：进程等待分配处理器，万事俱备，只欠CPU<br>⑤终止：进程已经执行完成</p><p><strong>7、分页和分段有什么区别（内存管理）？</strong>[/scode</p><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p><p>两者的不同点：</p><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p><p>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p><p>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p><p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p><p>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。<br>[scode type=”blue”]<strong>8、什么是虚拟内存？</strong></p><p><strong>1).内存的发展历程</strong></p><p>　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用) —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程)<br>）—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</p><p><strong>2).虚拟内存</strong></p><p>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。<br>虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址。如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。<br><strong>3). 页面置换算法</strong></p><p>FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p><p><strong>4). 虚拟内存的应用与优点</strong></p><p>　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p><p>在内存中可以保留多个进程，系统并发度提高<br>虚拟内存技术：允许将一个作业分多次调入内存。可以用分页式、分段式、段页式存储管理来实现。</p><p>    基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间放入将要调入内存的信息。这样，系统就好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p><p>9、局部性原理</p><p>(1). 时间上的局部性：最近被访问的页在不久的将来还会被访问；</p><p>(2). 空间上的局部性：内存中被访问的页周围的页也很可能被访问。</p><p>生产者消费者模型、哲学家就餐问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 进程和线程 </tag>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言面试</title>
      <link href="/posts/68fc.html"/>
      <url>/posts/68fc.html</url>
      
        <content type="html"><![CDATA[<p>1、预处理阶段都做了什么？**</p><p>①宏定义指令<br>②条件编译指令<br>③处理头文件包含<br>④特殊符号以及注释</p><p><strong>2、请你来说一下一个C++源文件从文本到可执行文件经历的过程</strong></p><p>①预处理 gcc -E a.c -o a.i<br>②编译 gcc -S a.c 生成a.s文件<br>③汇编 gcc -c a.c 生成a.o文件<br>④链接 gcc a.c 生成可执行文件a.out</p><p><strong>3、请你来说一下C++/C的内存分配？</strong></p><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0<del>3G是用户态空间，3</del>4G是内核空间<br>静态区域：<br>①<strong>代码段</strong>:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。<br>②<strong>数据段</strong>：存储程序中已初始化的全局变量和静态变量<br>③<strong>bss 段</strong>：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。<br>动态区域：<br>④<strong>堆区</strong>：调用new/malloc函数时在堆区动态分配内存，同时调用delete/free来手动释放申请的内存。<br>⑤<strong>文件映射区</strong>:存储动态链接库以及调用mmap函数进行的文件映射<br>⑥<strong>栈</strong>：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p><p><strong>4、说一下static关键字的作用？</strong></p><p>①<strong>全局静态变量</strong><br>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。<br>②<strong>局部静态变量</strong><br>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；<br>③<strong>静态函数</strong><br>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；<br>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；<br>④<strong>类的静态成员</strong><br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共同使用<br>⑤<strong>类的静态函数</strong><br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p><p><strong>5、说一下const关键字的作用？</strong></p><p>const是一个C语言的关键字，它限定一个变量不允许被改变。使用const在一定程度上可以提高程序的健壮性，另外，在观看别人代码的时候，清晰理解const所起的作用，对理解对方的程序也有一些帮助。但是<strong>在C语言中的const并不是真正的”const“，可以通过指针去修改const修饰的变量，C++中的const才是真正的const，不可以用指针修改，且必须在定义时进行初始化</strong></p><p>int const *pi; //这是一个指向整形常量的指针，可以修改指针的值，但是不能修改它所指向的值.<br>int *const pi; //这个是一个指向整形的常量指针，可以修改它所指向的值，但是不能修改指针的值。<br>int const *const pi;//这就是上边两种的综合了，都不可以修改.</p><p>在C++中：</p><p><strong>①const修饰数据成员</strong></p><p>const 修饰数据成员,称为常数据成员,可能被普通成员函数和常成员函数来使用,不可以更改。<strong>必须初始化</strong>,可以在类中,也就是在类中定义这个变量的同是初始化(不推荐),或初始化参数列表中(这是在类对象生成之前唯一一次改变 const 成员的值的机会了)。不可以在构造器中初始化，只能是初始化参数列表中初始化。否则报错。</p><p><strong>②const修饰成员函数</strong></p><p>const修饰成员函数承诺在本函数内部不会修改类内的数据成员,为此,也只能调用承诺不会改变成员的其它 const 成员函数,而不能调用其它非 const 成员函数。const 修饰函数放在,声明之后,实现体之前,大概也没有别的地方可以放了。</p><pre><code>void dis() const</code></pre><p><strong>③C++中的static const 类型</strong></p><p>如果一个类的成员,既要实现共享,又要实现不可改变,那就用 static const 组合模式来修饰。修饰成员函数,格式并无二异,修饰数据成员,必须要类内部初始化。</p><p><strong>6、说一下extern关键字的作用？</strong></p><p>①函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的。</p><p>②全局变量在外部使用声明时，extern关键字是必须的，如果变量没有extern修饰且没有显式的初始化，同样成为变量的定义，因此此时必须加extern，而编译器在此标记存储空间在执行时加载内并初始化为0。而局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存。</p><p>③全局变量或函数本质上讲没有区别，函数名是指向函数二进制块开头处的指针。而全局变量是在函数外部声明的变量。函数名也在函数外，因此函数也是全局的。</p><p>④<strong>在C++中还有</strong>：C++调用C函数需要extern “C”，因为C语言没有函数重载。C++ 既然完全兼容 C 语言,那么就面临着,完全兼容 C 的类库。由.c 文件的生成的库文件中函数名,并没有发生 namemangling 行为,而我们在包含.c 文件所对应的.h 文件时,.h文件要发生 name manling 行为,因而会在链接的时候发生的错误。C++为了避免上述错误的发生,重载了关键字 extern。只需要在避免 name manling的函数前,加 extern “C”,如有多个,则 extern “C”{ } 将函数的声明放入{}中即可。</p><p>我们可以在IDE中点进去C语言中的一个库进去看看，都是把整个声明的头文件包含在 extern “C”{ }的大括号当中的，从而实现了兼容C语言。</p><p><strong>7、说一下volatile关键字的作用？</strong></p><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</p><p>下面是volatile变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。<br>3). 下面的函数有什么错误：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token operator">*</span>ptr <span class="token operator">*</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面是答案：</p><p>这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Linux内核中不应该使用volatile，会使效率变慢，内核中使用了很多原语比如互斥锁等，防止了编译器的优化</p><p><strong>8、说一下register关键字的作用？</strong></p><p>在C语言中的register修饰的变量表示将此变量存储在CPU的寄存器中，由于CPU访问寄存器比访问内存快很多，可以大大提高运算速度。但在使用register时有几点需要注意。</p><p>①用register修饰的变量只能是局部变量，不能是全局变量。CPU的寄存器资源有限，因此不可能让一个变量一直占着CPU寄存器<br>②register变量一定要是CPU可以接受的值。<br>③不可以用&amp;运算符对register变量进行取址。<br>④register只是请求寄存器变量，不一定能够成功。</p><p><strong>9、请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</strong></p><p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p><p>①对于使用双引号包含的头文件，查找头文件路径的顺序为：当前头文件目录，编译器设置的头文件路径(编译器可使用-I显式指定搜索路径)，系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p><p>②对于使用尖括号包含的头文件，查找头文件的路径顺序为：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）,系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p><p><strong>10、C语言中的inline内联函数</strong></p><p>在c中,为了解决一些频繁调用的小函数大量消耗栈空间或是叫栈内存的问题，特别的引入了inline修饰符，表示为内联函数。inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已.为了方便,将内联函数直接声明时就定义,放在头文件中.这样其它文件包含了该头文件,就在每个文件都出现了内联函数的定义.就可以内联了.<br>inline关键字仅仅是建议编译器做内联展开处理，即是将函数直接嵌入调用程序的主体，省去了调用/返回指令。</p><p>内联函数一般都是一个函数大概在几行的时候才会去实现</p><p><strong>11、静态链接、动态链接</strong></p><p><strong>静态链接</strong>：在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个<em>.c文件会形成一个</em>.o文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接</p><p>静态链接库的制作：</p><p>①.gcc -c a.c -o a.o //生成二进制文件<br>②.ar -rc liba.a a.o //打包成静态库</p><p><strong>动态链接：</strong></p><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>下面简单介绍动态链接的过程：假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><p>静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</p><p>动态链接库制作：</p><p>gcc -c -fPIC -shared a.c -o liba.so</p><p><strong>12、gcc编译选项</strong></p><p>-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那么库名跟真正的库文件名有什么关系呢？就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，<strong>把库文件名的头lib和尾.so去掉就是库名了。</strong>放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，否则应使用-L参数跟着的是库文件所在的目录名。再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L /aaa/bbb/ccc -ltest</p><p>但是如果头文件不在/usr/include里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I /myinclude参数</p><p><strong>13、指针</strong></p><p>①指针数组：指针数组，是个数组，里边放的东西都是指针。char <em>p[2]={“china”,”linux”};<br>②数组指针：数组指针，是个指针，指向数组的指针.int (</em>p)[5]=a; //指向二维数组<br>③函数指针：int (*p)(int a,char b);//函数指针p指向返回值类型为int的，两个参数为int和char的函数<br>void *类型可以指向任何一个类型的指针</p><p><code>void (*signal(int sig, void (*func) (int))) (int)</code>signal仍然是一个函数，他返回一个函数指针，这个指针指向的函数没有返回值，只有一个int类型的参数</p><p>④字符数组与字符串指针：其中<code>char *p="linux"</code> 这种情况字符串Linux只存在于只读数据段中（rodata），所以p所指向的内容不可以被更改。<strong>所以有的字符串操作函数例如char *strcat(char *dst,char const *src);前面的参数dst,需要修改，只能传数组，不能直接传一个字符串，因为字符串不可改变</strong></p><p><strong>一定程度上可以认为一级指针与一维数组名等价，二级指针与指针数组名等价，数组指针与二维数组名等价。而二级指针和二维数组名没有一毛钱关系。</strong></p><p>⑤<code>*p++</code>：等同于：*p; p += 1;先运算再++</p><p><code>*++p</code>：等同于 p += 1; *p;先++再运算</p><p>⑥数组名引用+1 , &amp;a+1,是数组整个大小+1。数组名+1 , a+1是加一个数组元素。int等+1是真正的算术+1</p><p><strong>14、结构体大小的计算</strong></p><p>①整体所占的内存大小应该是结构中成员类型最大的整数倍，如果此处最大的类型是int_64t，占8个字节。即最后所占字节的总数应该是8的倍数，不足的补足<br>②数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面所有成员已经占用的空间大小必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。假设是地址是从0开始，结构体中第一个成员类型char型占一个字节，则内存地址0-1，第二成员从2开始，int型所占内存4个字节根据原则b，第一个成员所占内存补齐4的倍数，故第一个成员所占内存:1＋3＝4；第二个成员占5-8.第三个成员占8个字节，满足原则b，不需要补齐，占9-16第四个成员占一个字节，占17.故总内存为1＋3＋4＋8＋1＝17个字节，但根据原则1总字节数需是8的倍数，需将17补齐到24.故此结构体总字节数为:24字节</p><p><strong>15、共用体与大小端的判断</strong></p><p>共用体占用空间的大小取决于类型长度最大的，共用体变量的地址和它的各成员的地址都是同一地址。同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一种，而不是同时存放几种。共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</p><p>所谓的大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；所谓的小端模式，是指数据的低位保存在内存的低地址中，而数 据的高位保存在内存的高地址中。</p><p>判断代码：用联合体判断大小端，大端返回0，小端返回1</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> w<span class="token punctuation">{</span>     <span class="token keyword">int</span> a<span class="token punctuation">;</span>     <span class="token keyword">char</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>u<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    u test<span class="token punctuation">;</span>    test<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>16、strlen求字符串长度</strong></p><p>strlen求字符串长度为字符串的长度，不包括”0”</p><p><strong>17、C语言操作寄存器</strong></p><p><code>*((uint32 volatile *)(reg_addres)) = value;</code>将地址强制转化为uint32类型的指针，再解引用</p><p><strong>18、文件操作</strong></p><p>“r” 表示只读，“w” 表示只写，“rw” 表示读写，“a” 表示追加写入，b表示二进制文件，t表示文本文件，默认不写就是文本文件。</p><p>二进制读写：fread、fwrite</p><p>字符读写：fputc、fgetc、fgets、fputs</p><p>格式化读写：fprintf、fscanf</p><p>文件指针：rewind、fseek</p><p><strong>19、gcc工具链</strong></p><p>objdump：反汇编使用 参数：-d</p><p>readelf 显示elf文件信息</p><p>objcopy 把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。</p><p>strip 放弃所有符号连接，一般应用程序最终都要strip处理</p><p>nm 从目标文件列举所有变量</p><p>add2line 将地址转换成文件名或行号对，以便调试程序</p><p><strong>20、*“当表达式中存在有符号类型和无符号类型时，默认情况下计算的结果将转化为无符号类型”</strong></p><p><strong>21写一个“标准”宏，这个宏输入两个参数并返回较小的一个.#与##的作用？</strong></p><pre><code>#define MIN(x, y) ((x)&lt;(y)?(x):(y))``#是把宏参数转化为字符串的运算符，##是把两个宏参数连接的运算符。</code></pre><p><strong>22、sizeof关键字的作用？</strong></p><p>sizeof是在编译阶段处理，且不能被编译为机器码。sizeof的结果等于对象或类型所占的内存字节数。sizeof的返回值类型为size_t。<br>变量：int a; sizeof(a)为4；<br>指针：int <em>p; sizeof(p)为4；<br>数组：int b[10]; sizeof(b)为数组的大小，4</em>10；int c[0]; sizeof(c)等于0<br>结构体：struct (int a; char ch;)s1; sizeof(s1)为8 与结构体字节对齐有关。<br>sizeof(void)等于1<br>sizeof(void *)等于4</p><p><strong>23、堆栈溢出一般是由什么原因导致的？</strong></p><p>1.没有回收垃圾资源<br>2.层次太深的递归调用</p><p><strong>24、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</strong></p><pre class=" language-c"><code class="language-c">BOOL <span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>a <span class="token punctuation">)</span> or <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token punctuation">:</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">float</span> <span class="token punctuation">:</span>   <span class="token keyword">const</span> EXPRESSION EXP <span class="token operator">=</span> <span class="token number">0.000001</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">&lt;</span> EXP <span class="token operator">&amp;&amp;</span> a <span class="token operator">></span><span class="token operator">-</span>EXP<span class="token punctuation">)</span>pointer <span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> or <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></code></pre><p><strong>25、指针与数组的区别。</strong></p><p>数组是连续的，数组名就是数组的首地址，和一维指针类似。指针变量中存放的内容是一个地址变量，通过指针的解引用就可以访问到那个地址中的内容。</p><p><strong>25、指针与数组的区别。</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里对数组a取地址，加的大小是整个数组的大小。</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr2<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这时是地址+1，比如地址是0x2000000,加1之后就是0x20000001</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr3<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这是数组内容大小+1，比如地址是0x2000000,加1之后就是0x20000004</span></code></pre><p><strong>26、int main（）{}里面有几个参数，分别代表什么意思。</strong></p><p>其中第一个表示参数的个数；第二个参数中argv[0]为自身运行目录路径和程序名，argv[1]指向第一个参数、argv[2]指向第二个参数……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 面试 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++语言的区别</title>
      <link href="/posts/fb40.html"/>
      <url>/posts/fb40.html</url>
      
        <content type="html"><![CDATA[<p>1、说一下C++和C的区别？**</p><p><strong>设计思想上：</strong><br>C++是面向对象的语言，而C是面向过程的结构化编程语言<br><strong>语法上：</strong><br>C++具有封装、继承和多态三种特性<br>C++相比C，增加多许多类型安全的功能，比如强制类型转换、<br>C++支持范式编程，比如模板类、函数模板等</p><p><strong>2、C++中的拷贝构造函数传参为什么传引用？</strong></p><p>如果是传值的话，就会在拷贝构造函数内调用拷贝构造函数，会永无休止的递归从而导致栈溢出。因此C++不允许传值，会直接编译出错。</p><p><strong>3、赋值运算符重载函数中为什么传引用？</strong></p><p>如果不是引用而是实例，会调用一次拷贝构造函数，把参数声明为引用可以避免这个无谓的消耗，提高效率。同时，我们在赋值运算符内不会改变传入的参数，所以加上const。</p><p><strong>4、请你回答一下什么时候析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？</strong></p><p>在实现多态时，当一个类被作为基类并且该基类对派生类的对象进行操作，在析构时防止只析构基类而不析构派生类的状况发生。把基类的析构函数设计为虚函数可以在基类的指针指向派生类对象时，用基类的指针删除派生类对象，避免内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数所以C++的默认析构函数不是虚函数</p><p><strong>5、请你说一说多态实现的原理？</strong></p><p>编译器发现一个类中有虚函数，生成具体对象时保证了虚函数表的指针存在于对象实例中最前面的位置，生成虚函数表vtable。虚函数表的各表项为指向对应虚函数的指针。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，将vptr指向相应的vtable，将类与此类的vtable联系起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的this指针，这样依靠此this指针即可得到正确的vtable,如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。</p><p><strong>6、说一说c++中四种cast转换</strong></p><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>①const_cast<br>用于将const变量转为非const<br>②static_cast<br>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；<br>③dynamic_cast<br>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。<br>向上转换：指的是子类向基类的转换<br>向下转换：指的是基类向子类的转换<br>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。<br>④reinterpret_cast<br>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；<br>⑤为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><p><strong>7、请说一下C/C++ 中指针和引用的区别？</strong></p><p>①指针有自己的一块空间，而引用只是一个别名；<br>②使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；<br>③指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；<br>④作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；<br>⑤可以有const指针，但是没有const引用；<br>⑥指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；<br>⑦指针可以有多级指针（**p），而引用至于一级；<br>⑧指针和引用使用++运算符的意义不一样；<br>⑨如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p><p><strong>8、请你来说一说C++函数栈空间的最大值</strong></p><p>默认是1M，不过可以调整</p><p><strong>9、请你说说C语言参数压栈顺序？</strong></p><p>从右到左</p><p><strong>10、请你说说C++如何处理返回值？</strong></p><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p><p><em>11、请你回答一下malloc与new区别</em></p><p>1、malloc需要给定申请内存的大小，返回的指针需要强转。<br>2、new会调用构造函数，不用指定内存大小，返回的指针不用强转。<br>3、malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>4、对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。<br>5、既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。<br>6、new会调用构造函数，malloc不会；<br>7、new可以被重载，malloc不能。<br>问题2：malloc(0)返回值<br>答：如果请求的长度为0，则标准C语言函数malloc返回一个null指针或不能用于访问对象的非null指针，该指针能被free安全使用。</p><p><strong>12、请你说说虚函数表具体是怎样实现运行时多态的?</strong></p><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p><p><strong>13、请你回答一下静态函数和虚函数的区别</strong></p><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p><p><strong>14、请你说一说重载和覆盖和shadow</strong></p><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写<br>shadow：在父子类中，只要出现了重名标识符(函数成员，数据成员)，就会构成，shadow。在子类中如果想访问被shadow的成员，加上父类的命名空间</p><p><strong>15、请你来说一下C++中类成员的访问权限</strong></p><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p><p><strong>16、请你来说一下C++中struct和class的区别</strong></p><p>①在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。<br>②另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p><p>③C++中的struct可以定义函数</p><p>④C++中可以直接使用struct定义的变量，而C语言中要加上struct 变量才可以使用</p><p><strong>17、请你回答一下C++类内可以定义引用数据成员吗？</strong></p><p>可以，必须通过成员函数初始化列表初始化。</p><p><strong>18、深拷贝、深深的赋值</strong></p><p>①深拷贝：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>using namespace std<span class="token punctuation">;</span>class DataStr<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">DataStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">//构造器</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"constructor"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        _str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span><span class="token string">"C++ is the best language in the World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">DataStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> DataStr <span class="token operator">&amp;</span> another<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//深拷贝构造器</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"copy constructor"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        _str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建新的堆空间，分配内存 注意strlen求的长度</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//将传入的another对象内容拷贝一份给新的</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">DataStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//析构器</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"destructor"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        delete <span class="token punctuation">[</span><span class="token punctuation">]</span>_str<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>_str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>private<span class="token punctuation">:</span>    <span class="token keyword">char</span> <span class="token operator">*</span>_str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    DataStr ds<span class="token punctuation">;</span>    ds<span class="token punctuation">.</span><span class="token function">dis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DataStr ds2 <span class="token operator">=</span> ds<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用深拷贝构造器</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>②深深的赋值</p><pre class=" language-c"><code class="language-c">mystring <span class="token operator">&amp;</span> operator <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>this <span class="token operator">==</span> <span class="token operator">&amp;</span>another<span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//实现自赋值</span>    delete <span class="token punctuation">[</span><span class="token punctuation">]</span>this<span class="token operator">-></span>_str<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解决内存泄露，先销毁掉原来的空间</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决重析构double free问题</span>    _str <span class="token operator">=</span> new <span class="token keyword">char</span> <span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//实现连续赋值</span><span class="token punctuation">}</span></code></pre><p><strong>19、this 指针</strong></p><p>this指针就是指向调用对象的指针。系统在创建对象时,默认生成的指向当前对象的指针。这样作的目的,就是为了带来使用上的方便。</p><p><strong>this 指针的使用规则</strong></p><p>1、指向当前对象,可用于用所有的成员函数,但不能应用于初始化列表。</p><p>2、this 是以隐含参数的形式传入,而非成员的一部分,所以不会影响 sizeof(obj)对象的大小。</p><p>3、this 指针本身是不能更改指向的,即,是 const 类型修饰的。</p><p><strong>this 作用</strong></p><p>1、指向当前对象,避免入参与成员名相同</p><p>2、支持基于返回 this 引用的多重串联调用的函数(连续赋值)。</p><p><strong>20、派生类构造顺序</strong></p><p>由于子类中， 包含了两部分内容， 一部分来自， 父类， 一部分来自， 子类。 父类的部分， 要由调用父类的构造器来完成， 子类的部分， 在子类的构造器中来完成始化。 子类中，有内嵌的子对象(内嵌子对象就是类中的数据成员是其他类的一个对象)也需要构造。</p><p>子类会调用父类构造器，只有在父类含有标配的情况下才会调用，否则只能在子类中显示的调用。（标配就是不需要提供参数的构造器，也就是无参构造器或参数列表都有默认参数的情况），内嵌子对象也一样。<br>显示调用如下：<br><strong>注意：基类的构造器和内嵌子对象只能放在参数列表中，而且参数列表中的是内嵌子对象，是放的对象，不是类，而且基类和内嵌子对象顺序只能是下面这样</strong></p><pre class=" language-c"><code class="language-c">派生类名<span class="token punctuation">:</span><span class="token punctuation">:</span>派生类名<span class="token punctuation">(</span>总参列表<span class="token punctuation">)</span>    <span class="token punctuation">:</span>基类名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">,</span>内嵌子对象<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">{</span>    派生类新增成员的初始化语句<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//也可出现地参数列表中</span><span class="token punctuation">}</span></code></pre><p><strong>21、虚函数</strong></p><p><strong>虚函数必须是类的成员函数</strong>否则编译不过<br><strong>类的静态成员函数不能为虚函数</strong>否则编译不过<br><strong>构造函数不能为虚函数</strong>否则编译不过，它将在执行期间被构造， 而执行期则需要对象已经建立， 构造函数所完成的工作就是为了建立合适的对象， 因此在没有构建好的对象上不可能执行多态</p><p><strong>22、什么是RAII资源管理？</strong></p><p>即资源获取就是初始化，利用对象生命周期来控制程序资源，简单来说就是通过局部对象来处理一些资源问题</p><p><strong>23、实现单例模式</strong></p><pre class=" language-c"><code class="language-c">class Singleon<span class="token punctuation">{</span>private<span class="token punctuation">:</span>    <span class="token function">Singleon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Singleon()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> Singleon<span class="token operator">*</span>instrance<span class="token punctuation">;</span>public<span class="token punctuation">:</span>    <span class="token keyword">static</span> Singleon<span class="token operator">*</span> <span class="token function">GetSingleon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> instrance<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            instrance <span class="token operator">=</span> new <span class="token function">Singleon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"对象创建成功"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"对象已经创建成功，无须再建"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instrance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> Singleon<span class="token operator">*</span> <span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        delete instrance<span class="token punctuation">;</span>        instrance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Singleon<span class="token operator">*</span> Singleon<span class="token punctuation">:</span><span class="token punctuation">:</span>instrance <span class="token operator">=</span>  <span class="token constant">NULL</span><span class="token punctuation">;</span></code></pre><p><strong>24、实现string代码</strong></p><p>mystring.h</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MYSTRING_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>using  namespace std<span class="token punctuation">;</span>class mystring<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token function">mystring</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">mystring</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mystring</span><span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    mystring<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool operator <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool operator <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool operator <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool operator <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool operator <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    mystring operator <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    mystring<span class="token operator">&amp;</span> operator <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">;</span>    friend ostream <span class="token operator">&amp;</span> operator <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span> co<span class="token punctuation">,</span> <span class="token keyword">const</span> mystring<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    friend istream  <span class="token operator">&amp;</span> operator <span class="token operator">>></span> <span class="token punctuation">(</span>istream <span class="token operator">&amp;</span> ci<span class="token punctuation">,</span>  mystring<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private<span class="token punctuation">:</span>    <span class="token keyword">char</span> <span class="token operator">*</span> _str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// MYSTRING_H</span></code></pre><p>mystring.cpp</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mystring.h"</span></span>mystring<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">mystring</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//构造器</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">*</span>_str <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        _str <span class="token operator">=</span> new <span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>mystring<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">~</span><span class="token function">mystring</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//析构器</span><span class="token punctuation">{</span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span>_str<span class="token punctuation">;</span><span class="token punctuation">}</span>mystring<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">mystring</span><span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//拷贝构造器</span><span class="token punctuation">{</span>    _str <span class="token operator">=</span> new <span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>mystring<span class="token operator">&amp;</span> mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//赋值运算符重载</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>this <span class="token operator">==</span> <span class="token operator">&amp;</span>another<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        delete <span class="token punctuation">[</span><span class="token punctuation">]</span>this<span class="token operator">-></span>_str<span class="token punctuation">;</span>        _str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>bool mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>_str<span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>mystring mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span> _str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    mystring ms<span class="token punctuation">;</span>    delete <span class="token punctuation">[</span><span class="token punctuation">]</span>ms<span class="token punctuation">.</span>_str<span class="token punctuation">;</span>    ms<span class="token punctuation">.</span>_str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里的{0}一定要写，不然乱码</span>    <span class="token function">strcat</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>_str<span class="token punctuation">,</span>_str<span class="token punctuation">)</span><span class="token punctuation">,</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ms<span class="token punctuation">;</span><span class="token punctuation">}</span>mystring<span class="token operator">&amp;</span> mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mystring <span class="token operator">&amp;</span> another<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> catlen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> srclen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> catlen <span class="token operator">+</span> srclen<span class="token punctuation">;</span>    this <span class="token operator">-></span> _str <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">realloc</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_str<span class="token punctuation">,</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_str <span class="token operator">+</span> catlen<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> srclen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_str <span class="token punctuation">,</span> another<span class="token punctuation">.</span>_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">}</span>ostream <span class="token operator">&amp;</span> operator<span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span> co<span class="token punctuation">,</span> <span class="token keyword">const</span> mystring<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span><span class="token punctuation">{</span>    co <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>_str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> co<span class="token punctuation">;</span><span class="token punctuation">}</span>istream <span class="token operator">&amp;</span> operator<span class="token operator">>></span> <span class="token punctuation">(</span>istream <span class="token operator">&amp;</span> ci<span class="token punctuation">,</span>  mystring<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span><span class="token punctuation">{</span>    delete <span class="token punctuation">[</span><span class="token punctuation">]</span> ms<span class="token punctuation">.</span>_str<span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> c<span class="token punctuation">;</span>    ms<span class="token punctuation">.</span>_str <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>_str<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ci<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> mystring<span class="token punctuation">:</span><span class="token punctuation">:</span>operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> _str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> mystring<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> _str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span> <span class="token operator">*</span> mystring<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> _str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>25、什么是虚函数？什么是纯虚函数？</strong></p><p>虚函数是允许被其子类重新定义的成员函数。</p><p>虚函数的声明：virtual returntype func(parameter);引入虚函数的目的是为了动态绑定；</p><p>纯虚函数声明：virtual returntype func(parameter)=0；引入纯虚函数是为了派生接口。（使派生类仅仅只是继承函数的接口）</p><p><strong>26、基类为什么需要虚析构函数？</strong></p><p>C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><p><strong>27、当i是一个整数的时候i++和++i那个更快？它们的区别是什么？</strong></p><p>几乎一样。i++返回的是i的值，++i返回的是i+1的值，即++i是一个确定的值，是一个可以修改的左值。</p><p><strong>28、C++中类的成员函数与类的静态成员函数存储在代码段还是数据段还是哪里？C++中类的成员变量与类的静态成员变量存储在代码段还是数据段还是哪里？</strong></p><p>类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存<br>对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++总结（一）</title>
      <link href="/posts/27f1.html"/>
      <url>/posts/27f1.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.strlen 用于取字符串长度，需要头文件 cstring</strong></p><pre class=" language-cpp"><code class="language-cpp">size_t <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string）<span class="token punctuation">;</span>头文件：string<span class="token punctuation">.</span>h格式：strlen （字符数组名）功能：计算字符串s的（<span class="token keyword">unsigned</span> <span class="token keyword">int</span>型）长度，不包括<span class="token string">'\0'</span>在内说明：返回s的长度，不包括结束符<span class="token constant">NULL</span>。</code></pre><p><strong>2.gets() 用于接受连续的输入，包括空格，TAB</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">gets</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>3.gets,cin.get 的读取以程序运行开始</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>cin<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//直接触发第一次 </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>4. 以 EOF(End of file) 作为输入结尾</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span><span class="token string">"\n\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>cin 是 C ++ 的标准输入流，其本身是一个对象，并不存在返回值的概念。<br>不过经常会有类似于</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>a<span class="token punctuation">)</span></code></pre><p>的调用，这里并不是 cin 的返回值，而是 &gt;&gt; 操作重载函数</p><pre class=" language-cpp"><code class="language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span><span class="token punctuation">,</span> T <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>的返回值，其中第二个参数由 cin&gt;&gt; 后续参数类型决定。<br>其返回值类型为 istream&amp; 类型，大多数情况下其返回值为 cin 本身（非 0 值），只有当遇到 EOF 输入时，返回值为 0。</p><p><strong>5.string 用法总结</strong></p><p>\1. 长度<br>length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。</p><pre class=" language-cpp"><code class="language-cpp">string a<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>\2. 字符串的连接<br>除了可以使用 + 和 += 运算符对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。例如：</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s1 = "123abc"</span>s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s1 = "123abcbc"</span>s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'K'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s1 = "123abcbcKKK"</span>s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"ABCDE"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s1 = "123abcbcKKKCDE"，添加 "ABCDE" 的子串(2, 3)</span></code></pre><p>\3. 求 string 对象的子串<br>substr 成员函数可以用于求子串 (n, m)，原型如下：</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">substr</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> m <span class="token operator">=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span></code></pre><p>调用时，如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分。例如：</p><pre class=" language-cpp"><code class="language-cpp">string s1 <span class="token operator">=</span> <span class="token string">"this is ok"</span><span class="token punctuation">;</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s2 = "is i"</span>s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// s2 = "is is ok"</span></code></pre><p>\4. 查找子串和字符</p><ul><li>find：从前往后查找子串或字符出现的位置。</li><li>rfind：从后往前查找子串或字符出现的位置。</li><li>find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：</li><li>s1.find_first_of(“abc”); // 查找 s1 中第一次出现 “abc” 中任一字符的位置</li><li>find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</li><li>find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。</li><li>find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Source Code"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'u'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//查找 u 出现的位置</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1) "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出 l)2,urce Code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"Source"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//从下标3开始查找"Source"，找不到</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2) "</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Not Found"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出 2) Not Found</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"Co"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//查找子串"Co"。能找到，返回"Co"的位置</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"3) "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出 3) 7, Code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">"ceo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//查找第一次出现或 'c'、'e'或'o'的位置</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"4) "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出 4) l, ource Code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//查找最后一个 'e' 的位置</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"5) "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出 5) 10, e</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span><span class="token string">"eou"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//从下标1开始查找第一次出现非 'e'、'o' 或 'u' 字符的位置</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"6) "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出 6) 3, rce Code</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>\5. 替换子串<br>replace 成员函数可以对 string 对象中的子串进行替换，返回值为对象自身的引用。例如：</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Real Steel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用 "123456" 的子串(2,4) 替换 s1 的子串(1,3)</span>cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出 R3456 Steel</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"Harry Potter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用 5 个 '0' 替换子串(2,3)</span>cout <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出 HaOOOOO Potter</span><span class="token keyword">int</span> n <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"OOOOO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//查找子串 "00000" 的位置，n=2</span>s2<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"XXX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将子串(n,5)替换为"XXX"</span>cout <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出 HaXXX Potter</span></code></pre><p>\6. 删除子串<br>erase 成员函数可以删除 string 对象中的子串，返回值为对象自身的引用。例如：</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Real Steel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除子串(1, 3)，此后 s1 = "R Steel"</span>s1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除下标5及其后面的所有字符，此后 s1 = "R Ste"</span></code></pre><p>\7. 插入字符串<br>insert 成员函数可以在 string 对象中插入另一个字符串，返回值为对象自身的引用。例如：</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Limitless"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在下标 2 处插入字符串"123"，s1 = "Li123mitless"</span>s1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在下标 2 处插入 s2 , s1 = "Li10023mitless"</span>s1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在下标 3 处插入 5 个 'X'，s1 = "Li1XXXXX0023mitless"</span></code></pre><p>\8. 获取字符串元素<br>字符串中元素的访问是允许的，一般可使用两种方法访问字符串中的单一字符：下标操作符[] 和 成员函数 at()。两者均返回指定的下标位置的字符。第 1 个字符索引（下标）为 0，最后的字符索引为 length()-1。<br>\9. 将字符串转换为整数</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> stoi（<span class="token keyword">const</span> string＆str，size_t <span class="token operator">*</span> idx <span class="token operator">=</span> <span class="token number">0</span>，<span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span>）<span class="token punctuation">;</span><span class="token keyword">int</span> stoi（<span class="token keyword">const</span> wstring＆str，size_t <span class="token operator">*</span> idx <span class="token operator">=</span> <span class="token number">0</span>，<span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span>）<span class="token punctuation">;</span></code></pre><p>idx 为起始位置，base 为字符进制。<br>需 #include<string>，且为 c ++11 开始增加的新 api<br>DEV 设置方法：工具 -&gt; 编译器选项 -&gt; 代码生成 / 优化 -&gt; 代码生成 -&gt; 语言标准 (-std)<br>（Tools -&gt; Compiler Options -&gt; Setting -&gt; Code Generation -&gt; Language standard(-std)）<br>\10. 获取整行<br>在含有空格，TAB 的输入中需要用到 getline()</string></p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>\11. 反转字符 reverse<br>反转范围中元素的顺序 [first,last)，函数调用 iter_swap 将元素交换到新位置，该功能模板的行为等效于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">reverse</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span> BidirectionalIterator last<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>first<span class="token operator">!=</span>last<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>first<span class="token operator">!=</span><span class="token operator">--</span>last<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">iter_swap</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>first<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>需要头文件 #include<algorithm></algorithm></p><p><strong>6. 进制转换</strong><br>stoi 编译有风险，使用需谨慎 (hhhhh)</p><pre><code>code.cpp:28:23: error: 'stoi' was not declared in this scopecode.cpp:133:25: error: 'stoi' was not declared in this scopestring toAns(long long n, int ne)//10进制转化为任意进制{    if (n == 0)return "0";    string str;    while (n)    {        int tm = n % ne;        if (tm &lt;= 9)            str += '0' + tm;        else             str += 'A' + tm - 10;         n /= ne;    }    reverse(str.begin(), str.end());    return str;}long long toTen(string str, int ne)//任意进制转化为10进制{    long long ans = 0, arg = 1;    for (int i = str.size() - 1; i &gt;= 0; --i)    {        if (str[i] &lt;= '9')            ans += (str[i] - '0') * arg;        else            ans += (str[i] - 'A' + 10) * arg;        arg *= ne;    }    return ans;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一招搞定GitHub下载加速！</title>
      <link href="/posts/de40.html"/>
      <url>/posts/de40.html</url>
      
        <content type="html"><![CDATA[<h2 id="一招搞定GitHub下载加速！"><a href="#一招搞定GitHub下载加速！" class="headerlink" title="一招搞定GitHub下载加速！"></a>一招搞定GitHub下载加速！</h2><p>原创 hansonwong99 <a href="javascript:void(0);">CodeSheep</a> <em>1周前</em></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNV9Uwm56prIl3ajia5W6ZEwyUjmk7YlVXN6Yiaic2SuK3yRu3NTU3HCBKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><hr><h2 id="一个痛点"><a href="#一个痛点" class="headerlink" title="一个痛点"></a><strong>一个痛点</strong></h2><p>众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。</p><p>但是每当我们看到优秀的开源项目，准备去<strong>下（bai）载（piao）</strong>时，会发现 <code>git clone</code>的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 <code>20.00KiB/s</code>的时候，这简直太难受了。</p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNB8qf2qvJHnkHJZsGtGOBm3W0HqBaYicQQ7DFwWfkGQGZQNdBmuVC2Yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， <code>git clone</code> 大概率会失败！</p><p>当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。</p><hr><h2 id="“码云”是个好东西"><a href="#“码云”是个好东西" class="headerlink" title="“码云”是个好东西"></a><strong>“码云”是个好东西</strong></h2><p>接下来就介绍一种GitHub下载的加速方法：通过国内<strong>码云平台</strong>的转接，来完成GitHub上项目的下载加速。</p><blockquote><p>感谢公众号小伙伴ioc提供思路</p></blockquote><p><strong>（1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。</strong></p><p><strong>（2）点击右上角新建仓库的加号 <code>+</code>，选择“从 <code>GitHub/GitLab</code>导入仓库”菜单</strong></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNuxDta6zrnRY62TUCX4blM8Eaw0EiabKh9YnculvcIpujPdztzum9Ang/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>（3）然后填写位于 <code>GitHub</code>上你想 <code>clone</code>的仓库地址并导入</strong></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicN4jkGsI7gGEDP8VxGNNxGPkLia4oNzANkia5JTZcUibeDAYib5iblOW48Fjg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>这一步<strong>交给码云来做</strong>速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！</p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNn7GaKBJP0icPH9PwdycibxUJvshX886Iyu7jJN2AbJ3m5Y9xhXdcsXBw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>（4）接下来我们通过码云上的项目地址，将项目 <code>clone</code>到本地，这时候的clone速度就很快了，几 <code>MB/s</code>的速度是没问题的，很快项目就下载下来了。</strong></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNAD6nFlqorfqAw8icuZicnEhgFmOWyprlw5WJ7sicDLAoibH5rJKX88Mhug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。</p><hr><h2 id="重新关联远端地址"><a href="#重新关联远端地址" class="headerlink" title="重新关联远端地址"></a><strong>重新关联远端地址</strong></h2><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目<strong>完全脱离了</strong>，是另外一个<strong>副本</strong>。</p><p>在必要情况下（比如我们就是要给GitHub上的某个项目提 <code>PR</code>），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：</p><p><strong>（1）首先找到位于本地仓库目录下的隐藏文件夹 <code>.git</code></strong></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNoadIe377uP8ByZMESFqn6cdFXsG1Jw7akXV0NYg4gOD5tvbNILcqdg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>（2）用文本编辑器打开 <code>.git</code>文件夹中的 <code>config</code>配置文件</strong></p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNnmNVibavmCJRnF7vVhYMZIlfENg5CicLkGcO8MaMLPpv0EyzicranlUfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>将配置文件中的 <code>[remote"origin"].url</code>字段重新关联到原来位于GitHub上的GitHub项目地址</p><p><img src="./1.gif" data-original="https://mmbiz.qpic.cn/mmbiz_png/xq9PqibkVAzrQUnr62aOibZsG5lf4VpQicNQRick8gfWkrhSfjic8jRibK1kKkZL8y7VdEia7pL45KBoWUNIEIZfXpgIg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>当然你也可以通过命令行来修改远端地址，效果一样的</p></blockquote><p>至此大功告成，本地项目就相当于是 <code>clone</code>自GitHub，后续提代码，提 <code>PR</code>到GitHub上都没有问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Gitee </tag>
            
            <tag> 重新关联远端地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生毕业论文攻略</title>
      <link href="/posts/3626.html"/>
      <url>/posts/3626.html</url>
      
        <content type="html"><![CDATA[<h1 id="毕业论文完全攻略"><a href="#毕业论文完全攻略" class="headerlink" title="毕业论文完全攻略"></a>毕业论文完全攻略</h1><h2 id="1-选题思路"><a href="#1-选题思路" class="headerlink" title="1.选题思路"></a>1.选题思路</h2><p><a href="https://x.cnki.net/psmc/#/Home" target="_blank" rel="noopener">https://x.cnki.net/psmc/#/Home</a><br><a href="https://www.zhihu.com/question/264445355/answer/1037169234" target="_blank" rel="noopener">https://www.zhihu.com/question/264445355/answer/1037169234</a> 智能选题<br><a href="https://www.zhihu.com/question/22011864/answer/634959384" target="_blank" rel="noopener">https://www.zhihu.com/question/22011864/answer/634959384</a></p><h2 id="2-论文写作"><a href="#2-论文写作" class="headerlink" title="2.论文写作"></a>2.论文写作</h2><h3 id="文献下载"><a href="#文献下载" class="headerlink" title="文献下载"></a>文献下载</h3><p><a href="https://xue.glgoo.org/" target="_blank" rel="noopener">glgoo</a><br>大木虫<br><a href="https://gfsoso.99lb.net/" target="_blank" rel="noopener">https://gfsoso.99lb.net</a><br><a href="https://x.cnki.net/psmc/#/Home" target="_blank" rel="noopener">https://x.cnki.net/psmc/#/Home</a></p><h3 id="文献分析"><a href="#文献分析" class="headerlink" title="文献分析"></a>文献分析</h3><p><a href="https://zhuanlan.zhihu.com/p/20902898" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20902898</a><br><a href="https://zhuanlan.zhihu.com/p/49596927" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49596927</a></p><h3 id="降重软件"><a href="#降重软件" class="headerlink" title="降重软件"></a>降重软件</h3><p><a href="https://zhuanlan.zhihu.com/p/25121100" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25121100</a><br>考研同道 80<br><a href="https://ai.vpcvip.com/" target="_blank" rel="noopener">https://ai.vpcvip.com</a> 30<br><a href="https://www.beiying.online/#" target="_blank" rel="noopener">https://www.beiying.online/#</a><br>PP助手 免费</p><h3 id="写作逻辑"><a href="#写作逻辑" class="headerlink" title="写作逻辑"></a>写作逻辑</h3><p><a href="https://zhuanlan.zhihu.com/p/33468114" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33468114</a><br><a href="https://zhuanlan.zhihu.com/p/25121100" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25121100</a><br><a href="https://www.zhihu.com/question/21848942/answer/655445773" target="_blank" rel="noopener">https://www.zhihu.com/question/21848942/answer/655445773</a></p><h3 id="写作工具（OCR）"><a href="#写作工具（OCR）" class="headerlink" title="写作工具（OCR）"></a>写作工具（OCR）</h3><p><a href="https://www.zhihu.com/question/264445355/answer/1037169234" target="_blank" rel="noopener">https://www.zhihu.com/question/264445355/answer/1037169234</a></p><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p><a href="https://zhuanlan.zhihu.com/p/63253072" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63253072</a><br><a href="http://www.pc6.com/softview/SoftView_44903.html" target="_blank" rel="noopener">http://www.pc6.com/softview/SoftView_44903.html</a><br><a href="http://xkonglong.com/wordaddin/" target="_blank" rel="noopener">http://xkonglong.com/wordaddin/</a><br><a href="https://www.zhihu.com/question/29210586/answer/976007050" target="_blank" rel="noopener">https://www.zhihu.com/question/29210586/answer/976007050</a></p><h2 id="3-论文查重"><a href="#3-论文查重" class="headerlink" title="3.论文查重"></a>3.论文查重</h2><p><a href="http://biye.papersee.com.cn/" target="_blank" rel="noopener">http://biye.papersee.com.cn</a><br><a href="https://www.paperccb.com/" target="_blank" rel="noopener">https://www.paperccb.com</a><br><a href="http://www.zaojiance.com/?isLogin=1" target="_blank" rel="noopener">http://www.zaojiance.com/?isLogin=1</a><br>百度学术<br><a href="https://www.paperpass.com/" target="_blank" rel="noopener">https://www.paperpass.com</a><br><a href="http://www.gocheck.cn/" target="_blank" rel="noopener">http://www.gocheck.cn</a><br><a href="http://www.copycheck.com.cn/index.jsp" target="_blank" rel="noopener">http://www.copycheck.com.cn/index.jsp</a><br><a href="http://www.zhongguosou.com/zonghe/fanchaoxi.html" target="_blank" rel="noopener">http://www.zhongguosou.com/zonghe/fanchaoxi.html</a><br>paperok<br>papertime<br>paperfree<br>论文狗<br>格子达<br>paperyy<br>论文潜搜<br><a href="https://www.paperccb.com/" target="_blank" rel="noopener">https://www.paperccb.com</a></p><h2 id="4-论文答辩"><a href="#4-论文答辩" class="headerlink" title="4.论文答辩"></a>4.论文答辩</h2><p><a href="https://zhuanlan.zhihu.com/p/53937763" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53937763</a><br><a href="https://zhuanlan.zhihu.com/p/61889578" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61889578</a><br><a href="http://www.zhongguosou.com/zonghe/fanchaoxi.html" target="_blank" rel="noopener">http://www.zhongguosou.com/zonghe/fanchaoxi.html</a><br><a href="https://zhuanlan.zhihu.com/p/40513078" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40513078</a><br><a href="https://zhuanlan.zhihu.com/p/63820523" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63820523</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 毕业论文 </tag>
            
            <tag> 查重 </tag>
            
            <tag> 排版 </tag>
            
            <tag> 答辩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++为什么要引入auto</title>
      <link href="/posts/c76d.html"/>
      <url>/posts/c76d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要引入auto？"><a href="#1-为什么要引入auto？" class="headerlink" title="1. 为什么要引入auto？"></a>1. 为什么要引入auto？</h2><p>通常，在把表达式的值赋给变量时，我们需要在声明变量时准确地声明是什么类型。但是，有时候很难知道表达式到底是什么类型的，因此引入了auto类型说明符。auto会让编译器通过初始值来推算变量的类型。</p><h2 id="2-使用auto需要注意的是"><a href="#2-使用auto需要注意的是" class="headerlink" title="2. 使用auto需要注意的是"></a>2. 使用auto需要注意的是</h2><h3 id="auto定义的变量必须有初始值"><a href="#auto定义的变量必须有初始值" class="headerlink" title="auto定义的变量必须有初始值"></a><strong>auto定义的变量必须有初始值</strong></h3><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//由val1和val2相加的结果可以推断出item的类型 </span></code></pre><h3 id="一条auto声明语句只能有一个基本数据类型"><a href="#一条auto声明语句只能有一个基本数据类型" class="headerlink" title="一条auto声明语句只能有一个基本数据类型"></a><strong>一条auto声明语句只能有一个基本数据类型</strong></h3><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：i是整数，p是整型指针</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//错误：sz和pi的类型不一致</span></code></pre><h3 id="编译器会改变推断结果使其更符合初始化规则"><a href="#编译器会改变推断结果使其更符合初始化规则" class="headerlink" title="编译器会改变推断结果使其更符合初始化规则"></a><strong>编译器会改变推断结果使其更符合初始化规则</strong></h3><p>比如，我们在使用一个引用时，其实就是使用该引用的对象。特别是引用被用作初始值时，真正参加初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">auto</span> a <span class="token operator">=</span> r<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a是一个整数（r是i的别名，而i是一个整数）</span></code></pre><h3 id="auto一般会忽略顶层const，保留底层const"><a href="#auto一般会忽略顶层const，保留底层const" class="headerlink" title="auto一般会忽略顶层const，保留底层const"></a><strong>auto一般会忽略顶层const，保留底层const</strong></h3><blockquote><p>顶层const表示指针本身是个常量<br>底层const表示表示指针所指的对象是个常量</p></blockquote><ol><li>比如当初始值指向一个常量指针时：</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//b是一个整数（ci的顶层特性被忽略掉了）</span>   <span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span>   <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//d是一个整型指针（整数的地址就是指向整数的指针）</span>   <span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></code></pre><ol start="2"><li>如果希望推断出的auto类型是一个顶层const，需要明确指出：</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ci的推演类型是int，f是const int</span></code></pre><ol start="3"><li>引用的类型设为auto，原来的初始化规则仍然适用</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//g是一个整型常量引用，绑定到ci</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：不能为非常量引用绑定字面值</span>   <span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正确：可以为常量引用绑定字面值</span></code></pre><p>   设置一个auto类型的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初值绑定一个引用，则此时的常量就不是顶层常量了。</p><ol start="4"><li>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</li></ol><p>   cpp</p><pre class=" language-cpp"><code class="language-cpp">   <span class="token keyword">auto</span> k <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">&amp;</span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//k是整数，l是整型引用</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//m是整型常量的引用，p是指向整型常量的指针</span>   <span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：i是整型int，而&amp;ci是整型常量const int</span></code></pre><h2 id="3-完整实例代码"><a href="#3-完整实例代码" class="headerlink" title="3. 完整实例代码"></a>3. 完整实例代码</h2><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//由val1和val2相加的结果可以推断出item的类型 </span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//正确：i是整数，p是整型指针</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：sz和pi的类型不一致</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//b是一个整数（ci的顶层特性被忽略掉了）</span><span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//d是一个整型指针（整数的地址就是指向整数的指针）</span><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span><span class="token keyword">const</span> <span class="token keyword">auto</span> f <span class="token operator">=</span> ci<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//ci的推演类型是int，f是const int</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> ci<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//g是一个整型常量引用，绑定到ci</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>h <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误：不能为非常量引用绑定字面值</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//正确：可以为常量引用绑定字面值</span><span class="token keyword">auto</span> k <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">&amp;</span>l <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//k是整数，l是整型引用</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> ci<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//m是整型常量的引用，p是指向整型常量的指针</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误：i是整型int，而&amp;ci是整型常量const int</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> auto </tag>
            
            <tag> C++ </tag>
            
            <tag> C++语言规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP传输协议</title>
      <link href="/posts/f5b7.html"/>
      <url>/posts/f5b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再向服务器发一个确认ACK K+1</li></ul><p>这就完了三次握手，但是这三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="./1.gif" data-original="https://tva4.sinaimg.cn/large/005JD0Ejgy1gctbsm9xt8j30c406ddfy.jpg" alt="socket中发送的TCP三次握手"></p><p><strong>socket中发送的TCP三次握手</strong></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求并向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="./1.gif" data-original="https://tva4.sinaimg.cn/large/005JD0Ejgy1gctbtt46saj30a606d74c.jpg" alt="socket中发送的TCP四次握手"></p><p><strong>socket中发送的TCP四次握手</strong></p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> TCP握手协议 </tag>
            
            <tag> 客户端/服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket函数</title>
      <link href="/posts/16d9.html"/>
      <url>/posts/16d9.html</url>
      
        <content type="html"><![CDATA[<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用<code>bind()</code>函数，否则就当调用<code>connect()</code>、<code>listen()</code>时系统会自动随机分配一个端口。</p><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过<code>socket()</code>函数创建了，唯一标识一个socket。<code>bind()</code>函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p></li></ul><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">struct</span> sockaddr_in <span class="token punctuation">{</span>    sa_family_t    sin_family<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* address family: AF_INET */</span>    in_port_t      sin_port<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* port in network byte order */</span>    <span class="token keyword">struct</span> in_addr sin_addr<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* internet address */</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Internet address. */</span>  <span class="token keyword">struct</span> in_addr <span class="token punctuation">{</span>    uint32_t       s_addr<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* address in network byte order */</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>  ipv6对应的是：</p><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">struct</span> sockaddr_in6 <span class="token punctuation">{</span>     sa_family_t     sin6_family<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* AF_INET6 */</span>     in_port_t       sin6_port<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* port number */</span>     uint32_t        sin6_flowinfo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* IPv6 flow information */</span>     <span class="token keyword">struct</span> in6_addr sin6_addr<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* IPv6 address */</span>     uint32_t        sin6_scope_id<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Scope ID (new in 2.4) */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> in6_addr <span class="token punctuation">{</span>     <span class="token keyword">unsigned</span> <span class="token keyword">char</span>   s6_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* IPv6 address */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>  Unix域对应的是：</p><p>  cpp</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token macro property">#<span class="token directive keyword">define</span> UNIX_PATH_MAX    108</span>  <span class="token keyword">struct</span> sockaddr_un <span class="token punctuation">{</span>     sa_family_t sun_family<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* AF_UNIX */</span>     <span class="token keyword">char</span>        sun_path<span class="token punctuation">[</span>UNIX_PATH_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* pathname */</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>addrlen：对应的是地址的长度。</li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用<code>bind()</code>，而客户端就不会调用，而是在<code>connect()</code>时由系统随机生成一个。</p><blockquote><p>网络字节序与主机字节序<br><strong>主机字节序</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br><strong>网络字节序</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。<strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br><strong>所以</strong>：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p></blockquote><h2 id="listen函数、connect函数"><a href="#listen函数、connect函数" class="headerlink" title="listen函数、connect函数"></a>listen函数、connect函数</h2><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个socket，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>TCP服务器端依次调用<code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的socket地址了。TCP客户端依次调用<code>socket()</code>、<code>connect()</code>之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用<code>accept()</code>函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p><strong>注意</strong>：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个<strong>已连接socket描述字</strong>，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p><h2 id="read函数、write函数"><a href="#read函数、write函数" class="headerlink" title="read函数、write函数"></a>read函数、write函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li><code>read()</code>/<code>write()</code></li><li><code>recv()</code>/<code>send()</code></li><li><code>readv()</code>/<code>writev()</code></li><li><code>recvmsg()</code>/<code>sendmsg()</code></li><li><code>recvfrom()</code>/<code>sendto()</code></li></ul><p>它们的声明如下：</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>ssize_t <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>dest_addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>                        <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">recvmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h2 id="使用Socket-API建立简易TCP服务器"><a href="#使用Socket-API建立简易TCP服务器" class="headerlink" title="使用Socket API建立简易TCP服务器"></a>使用Socket API建立简易TCP服务器</h2><ol><li>建立一个Socket</li><li>绑定接受客户端连接的端口 bind</li><li>监听网络端口 listen</li><li>等待接收客户端连接 accept</li><li>向客户端发送一条数据 send</li><li>关闭Socket closesocket</li></ol><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> WIN32_LEAN_AND_MEAN</span><span class="token macro property">#<span class="token directive keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;Windows.h&gt;</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;WinSock2.h&gt;</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//启动Windows Socket 2.x 环境</span>    WORD ver <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WSADATA dat<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span>ver<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">// 1 建立一个Socket 套接字</span>    SOCKET _sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span>IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>INVALID_SOCKET <span class="token operator">==</span> _sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to new a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: New a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>           <span class="token comment" spellcheck="true">//IPv4的网络套接字 //面向数据流 //TCP协议</span>    <span class="token comment" spellcheck="true">// 2 bind 绑定接受客户端连接的端口 </span>    sockaddr_in _sin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">4567</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//host to net unsigned short</span>    _sin<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//net_addr("127.0.0.1");</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> <span class="token function">bind</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_sin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:绑定网络端口失败...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"绑定网络端口成功...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3 listen 监听网络端口 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> <span class="token function">listen</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:监听网络端口失败...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"监听网络端口成功...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 4 accept等待接收客户端连接 </span>    sockaddr_in clientAddr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nAddrLen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    SOCKET _cSock <span class="token operator">=</span> INVALID_SOCKET<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> msgBuf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, I'm Server."</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        _cSock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clientAddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nAddrLen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> _cSock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:接收到无效客户端SOCKET...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"新客户端加入：IP = %s \n"</span><span class="token punctuation">,</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>clientAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 5 send 向客户端发送一条数据 </span>        <span class="token function">send</span><span class="token punctuation">(</span>_cSock<span class="token punctuation">,</span> msgBuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msgBuf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 6 关闭套接字Socket closesocket</span>    <span class="token function">closesocket</span><span class="token punctuation">(</span>_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//清除windows socket 环境</span>    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="使用Socket-API建立简易TCP客户端"><a href="#使用Socket-API建立简易TCP客户端" class="headerlink" title="使用Socket API建立简易TCP客户端"></a>使用Socket API建立简易TCP客户端</h2><ol><li>建立一个Socket</li><li>connect 连接服务器</li><li>recv 接收服务器信息</li><li>关闭Socket closesocket</li></ol><p>cpp</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> WIN32_LEAN_AND_MEAN</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;Windows.h&gt;</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;WinSock2.h&gt;</span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//启动Windows Socket 2.x 环境</span>    WORD ver <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WSADATA dat<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span>ver<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//-- 使用Socket API建立简易TCP客服端</span>    <span class="token comment" spellcheck="true">// 1 建立一个Socket</span>    SOCKET _sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>INVALID_SOCKET <span class="token operator">==</span> _sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to new a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: New a Socket...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2 connect 连接服务器 </span>    sockaddr_in _sin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">4567</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _sin<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_sin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sockaddr_in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCKET_ERROR <span class="token operator">==</span> ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: Fail to connect to Server...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Success: Connect to Server...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3 recv 接收服务器信息</span>    <span class="token keyword">char</span> recvBuf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nlen <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>_sock<span class="token punctuation">,</span> recvBuf<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nlen <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive Data: %s \n"</span><span class="token punctuation">,</span> recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 4 关闭Socket closesocket</span>    <span class="token function">closesocket</span><span class="token punctuation">(</span>_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//----------------</span>    <span class="token comment" spellcheck="true">//清除windows socket 环境</span>    <span class="token function">WSACleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="./1.gif" data-original="https://tvax4.sinaimg.cn/large/005JD0Ejgy1gcdoxi7loej30pv0fpdgm.jpg" alt="服务端"></p><p><strong>服务端</strong></p><p><img src="./1.gif" data-original="https://tvax3.sinaimg.cn/large/005JD0Ejgy1gcdoxy5g1bj30qb0fgq3l.jpg" alt="客户端"></p><p><strong>客户端</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> socket函数 </tag>
            
            <tag> TCP客户端/服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket函数</title>
      <link href="/posts/16d9.html"/>
      <url>/posts/16d9.html</url>
      
        <content type="html"><![CDATA[<p><strong>## socket函数</strong></p><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>cpp</p><p>```cpp</p><p>int socket(int domain, int type, int protocol);</p><p>```</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><p>- domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p><p>- type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</p><p>- protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</p><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用<code>bind()</code>函数，否则就当调用<code>connect()</code>、<code>listen()</code>时系统会自动随机分配一个端口。</p><p><strong>## bind函数</strong></p><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><p>cpp</p><p>```cpp</p><p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><p>```</p><p>函数的三个参数分别为：</p><p>- sockfd：即socket描述字，它是通过<code>socket()</code>函数创建了，唯一标识一个socket。<code>bind()</code>函数就是将给这个描述字绑定一个名字。</p><p>- addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><p>  cpp</p><p>  ```cpp</p><p>  struct sockaddr_in {</p><p>​    sa_family_t    sin_family; /* address family: AF_INET */</p><p>​    in_port_t      sin_port;   /* port in network byte order */</p><p>​    struct in_addr sin_addr;   /* internet address */</p><p>  };</p><p>  /* Internet address. */</p><p>  struct in_addr {</p><p>​    uint32_t       s_addr;     /* address in network byte order */</p><p>  };</p><p>  ```</p><p>  ipv6对应的是：</p><p>  cpp</p><p>  ```cpp</p><p>  struct sockaddr_in6 { </p><p>​    sa_family_t     sin6_family;   /* AF_INET6 */ </p><p>​    in_port_t       sin6_port;     /* port number */ </p><p>​    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </p><p>​    struct in6_addr sin6_addr;     /* IPv6 address */ </p><p>​    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </p><p>  };</p><p>  struct in6_addr { </p><p>​    unsigned char   s6_addr[16];   /* IPv6 address */ </p><p>  };</p><p>  ```</p><p>  Unix域对应的是：</p><p>  cpp</p><p>  ```cpp</p><p>  #define UNIX_PATH_MAX    108</p><p>  struct sockaddr_un { </p><p>​    sa_family_t sun_family;               /* AF_UNIX */ </p><p>​    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </p><p>  };</p><p>  ```</p><p>- addrlen：对应的是地址的长度。</p><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用<code>bind()</code>，而客户端就不会调用，而是在<code>connect()</code>时由系统随机生成一个。</p><p>&gt; 网络字节序与主机字节序</p><p>&gt; <strong><em>\</em>主机字节序**</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p><p>&gt; a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>&gt; b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p>&gt; <strong><em>\</em>网络字节序**</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。<strong><em>\</em>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。**</strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>&gt; <strong><em>\</em>所以**</strong>：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p><p><strong>## listen函数、connect函数</strong></p><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个socket，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。</p><p>cpp</p><p>```cpp</p><p>int listen(int sockfd, int backlog);</p><p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><p>```</p><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><p><strong>## accept函数</strong></p><p>TCP服务器端依次调用<code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的socket地址了。TCP客户端依次调用<code>socket()</code>、<code>connect()</code>之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用<code>accept()</code>函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><p>cpp</p><p>```cpp</p><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><p>```</p><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p><strong><em>\</em>注意**</strong>：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong><em>\</em>监听socket描述字**</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个<strong><em>\</em>已连接socket描述字**</strong>，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p><p><strong>## read函数、write函数</strong></p><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><p>- <code>read()</code>/<code>write()</code></p><p>- <code>recv()</code>/<code>send()</code></p><p>- <code>readv()</code>/<code>writev()</code></p><p>- <code>recvmsg()</code>/<code>sendmsg()</code></p><p>- <code>recvfrom()</code>/<code>sendto()</code></p><p>它们的声明如下：</p><p>cpp</p><p>```cpp</p><p>#include &lt;unistd.h&gt;</p><p>ssize_t read(int fd, void *buf, size_t count);</p><p>ssize_t write(int fd, const void *buf, size_t count);</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;sys/socket.h&gt;</p><p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p><p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p><p>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</p><p>​                      const struct sockaddr *dest_addr, socklen_t addrlen);</p><p>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</p><p>​                        struct sockaddr *src_addr, socklen_t *addrlen);</p><p>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</p><p>ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</p><p>```</p><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p><p><strong>## close函数</strong></p><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><p>cpp</p><p>```cpp</p><p>#include &lt;unistd.h&gt;</p><p>int close(int fd);</p><p>```</p><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><p><strong>## 使用Socket API建立简易TCP服务器</strong></p><p>\1. 建立一个Socket</p><p>\2. 绑定接受客户端连接的端口 bind</p><p>\3. 监听网络端口 listen</p><p>\4. 等待接收客户端连接 accept</p><p>\5. 向客户端发送一条数据 send</p><p>\6. 关闭Socket closesocket</p><p>cpp</p><p>```cpp</p><p>#define WIN32_LEAN_AND_MEAN</p><p>#define _WINSOCK_DEPRECATED_NO_WARNINGS</p><p>#include&lt;Windows.h&gt;</p><p>#include&lt;WinSock2.h&gt;</p><p>#include&lt;stdio.h&gt;</p><p>int main()</p><p>{</p><p>​    //启动Windows Socket 2.x 环境</p><p>​    WORD ver = MAKEWORD(2, 2);</p><p>​    WSADATA dat;</p><p>​    WSAStartup(ver, &amp;dat);</p><p>​    //—————-</p><p>​    // 1 建立一个Socket 套接字</p><p>​    SOCKET _sock = socket(AF_INET, SOCK_STREAM,IPPROTO_TCP);</p><p>​    if (INVALID_SOCKET == _sock) {</p><p>​        printf(“ERROR: Fail to new a Socket…\n”);</p><p>​    }</p><p>​    else {</p><p>​        printf(“Success: New a Socket…\n”);</p><p>​    }</p><p>​           //IPv4的网络套接字 //面向数据流 //TCP协议</p><p>​    // 2 bind 绑定接受客户端连接的端口 </p><p>​    sockaddr_in _sin = {};</p><p>​    _sin.sin_family = AF_INET;</p><p>​    _sin.sin_port = htons(4567); //host to net unsigned short</p><p>​    _sin.sin_addr.S_un.S_addr = INADDR_ANY;//net_addr(“127.0.0.1”);</p><p>​    if (SOCKET_ERROR == bind(_sock, (sockaddr*)&amp;_sin, sizeof(sockaddr_in))) {</p><p>​        printf(“错误:绑定网络端口失败…\n”);</p><p>​    }</p><p>​    else {</p><p>​        printf(“绑定网络端口成功…\n”);</p><p>​    }</p><p>​    // 3 listen 监听网络端口 </p><p>​    if (SOCKET_ERROR == listen(_sock, 5)){</p><p>​        printf(“错误:监听网络端口失败…\n”);</p><p>​    }</p><p>​    else {</p><p>​        printf(“监听网络端口成功…\n”);</p><p>​    }</p><p>​    // 4 accept等待接收客户端连接 </p><p>​    sockaddr_in clientAddr = {};</p><p>​    int nAddrLen = sizeof(sockaddr);</p><p>​    SOCKET _cSock = INVALID_SOCKET;</p><p>​    const char msgBuf[] = “Hello, I’m Server.”;</p><p>​    while (true) {</p><p>​        _cSock = accept(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</p><p>​        if (SOCKET_ERROR == _cSock) {</p><p>​            printf(“错误:接收到无效客户端SOCKET…\n”);</p><p>​        }</p><p>​        printf(“新客户端加入：IP = %s \n”, inet_ntoa(clientAddr.sin_addr));</p><p>​        // 5 send 向客户端发送一条数据 </p><p>​        send(_cSock, msgBuf, strlen(msgBuf) + 1, 0);</p><p>​    }</p><p>​    // 6 关闭套接字Socket closesocket</p><p>​    closesocket(_sock);</p><p>​    //—————-</p><p>​    //清除windows socket 环境</p><p>​    WSACleanup();</p><p>​    return 0;</p><p>}</p><p>```</p><p><strong>## 使用Socket API建立简易TCP客户端</strong></p><p>\1. 建立一个Socket</p><p>\2. connect 连接服务器</p><p>\3. recv 接收服务器信息</p><p>\4. 关闭Socket closesocket</p><p>cpp</p><p>```cpp</p><p>#define WIN32_LEAN_AND_MEAN</p><p>#include&lt;Windows.h&gt;</p><p>#include&lt;WinSock2.h&gt;</p><p>#include&lt;stdio.h&gt;</p><p>int main()</p><p>{</p><p>​    //启动Windows Socket 2.x 环境</p><p>​    WORD ver = MAKEWORD(2, 2);</p><p>​    WSADATA dat;</p><p>​    WSAStartup(ver, &amp;dat);</p><p>​    //—————-</p><p>​    //– 使用Socket API建立简易TCP客服端</p><p>​    // 1 建立一个Socket</p><p>​    SOCKET _sock = socket(AF_INET, SOCK_STREAM, 0);</p><p>​    if (INVALID_SOCKET == _sock) {</p><p>​        printf(“ERROR: Fail to new a Socket…\n”);</p><p>​    }</p><p>​    else {</p><p>​        printf(“Success: New a Socket…\n”);</p><p>​    }</p><p>​    // 2 connect 连接服务器 </p><p>​    sockaddr_in _sin = {};</p><p>​    _sin.sin_family = AF_INET;</p><p>​    _sin.sin_port = htons(4567);</p><p>​    _sin.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</p><p>​    int ret = connect(_sock, (sockaddr*)&amp;_sin, sizeof(sockaddr_in));</p><p>​    if (SOCKET_ERROR == ret) {</p><p>​        printf(“ERROR: Fail to connect to Server…\n”);</p><p>​    }</p><p>​    else {</p><p>​        printf(“Success: Connect to Server…\n”);</p><p>​    }</p><p>​    // 3 recv 接收服务器信息</p><p>​    char recvBuf[256];</p><p>​    int nlen = recv(_sock, recvBuf, 256, 0);</p><p>​    if (nlen &gt; 0) {</p><p>​        printf(“Receive Data: %s \n”, recvBuf);</p><p>​    }</p><p>​    // 4 关闭Socket closesocket</p><p>​    closesocket(_sock);</p><p>​    //—————-</p><p>​    //清除windows socket 环境</p><p>​    WSACleanup();</p><p>​    getchar();</p><p>​    return 0;</p><p>}</p><p>```</p><p><strong>## 运行效果</strong></p><p><img src="./1.gif" data-original="https://tvax4.sinaimg.cn/large/005JD0Ejgy1gcdoxi7loej30pv0fpdgm.jpg" alt="服务端"></p><p><strong><em>\</em>服务端**</strong></p><p><img src="./1.gif" data-original="https://tvax3.sinaimg.cn/large/005JD0Ejgy1gcdoxy5g1bj30qb0fgq3l.jpg" alt="客户端"></p><p><strong><em>\</em>客户端**</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> socket函数 </tag>
            
            <tag> TCP客户端/服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/posts/b54b.html"/>
      <url>/posts/b54b.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​     Linux 具有<a href="https://baike.baidu.com/item/开放源码/7176422" target="_blank" rel="noopener">开放源码</a>、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。这些特点使得Linux成为开发路由交换设备的理想开发平台。</p><h3 id="1-tar打包"><a href="#1-tar打包" class="headerlink" title="1. tar打包"></a>1. tar打包</h3><p>Linux tar命令用于备份文件。tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><p>语法如下：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F ][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]</code></pre></blockquote><p>参数：</p><ul><li>-A或–catenate 新增文件到已存在的备份文件。</li><li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li><li>-B或–read-full-records 读取数据时重设区块大小。</li><li>-c或–create 建立新的备份文件。</li><li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li><li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li><li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li><li>-g或–listed-incremental 处理GNU格式的大量备份。</li><li>-G或–incremental 处理旧的GNU格式的大量备份。</li><li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li><li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li><li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li><li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li><li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li><li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li><li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li><li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li><li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li><li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li><li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li><li>-p或–same-permissions 用原来的文件权限还原文件。</li><li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。</li><li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li><li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li><li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li><li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li><li>-t或–list 列出备份文件的内容。</li><li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li><li>-u或–update 仅置换较备份文件内的文件更新的文件。</li><li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li><li>-v或–verbose 显示指令执行过程。</li><li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li><li>-w或–interactive 遭遇问题时先询问用户。</li><li>-W或–verify 写入备份文件后，确认文件正确无误。</li><li>-x或–extract或–get 从备份文件中还原文件。</li><li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li><li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li><li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li><li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li><li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li><li>–atime-preserve 不变更文件的存取时间。</li><li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li><li>–checkpoint 读取备份文件时列出目录名称。</li><li>–concatenate 此参数的效果和指定”-A”参数相同。</li><li>–confirmation 此参数的效果和指定”-w”参数相同。</li><li>–delete 从备份文件中删除指定的文件。</li><li>–exclude=&lt;范本样式&gt; 排除符合范本样式的文件。</li><li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li><li>–help 在线帮助。</li><li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li><li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li><li>–newer-mtime 只保存更改过的文件。</li><li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li><li>–null 从null设备读取文件名称。</li><li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li><li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li><li>–posix 将数据写入备份文件时使用POSIX格式。</li><li>–preserve 此参数的效果和指定”-ps”参数相同。</li><li>–preserve-order 此参数的效果和指定”-A”参数相同。</li><li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li><li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li><li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li><li>–remove-files 文件加入备份文件后，就将其删除。</li><li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li><li>–same-owner 尝试以相同的文件拥有者还原文件。</li><li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li><li>–totals 备份文件建立后，列出文件大小。</li><li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li><li>–version 显示版本信息。</li><li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li></ul><p>常用案例：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">tar -czvf test.tar.gz a.c   //压缩a.c文件为test.tar.gztar -tzvf test.tar.gz       //列出压缩文件内容tar -xzvf test.tar.gz       //解压文件</code></pre></blockquote><h3 id="2-find查找"><a href="#2-find查找" class="headerlink" title="2. find查找"></a>2. find查找</h3><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>语法：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></pre></blockquote><p>参数说明：</p><blockquote><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2</p></blockquote><p>常用命令案例：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">//将当前目录及其子目录下所有延伸档名是 c 的文件列出来find . -name "*.c"//将当前目录其其下子目录中所有一般文件列出find . -type f//将当前目录及其子目录下所有最近 20 天内更新过的文件列出find . -ctime -20//查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们find /var/log -type f -mtime +7 -ok rm {} \;//查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件find . -type f -perm 644 -exec ls -l {} \;//为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径find / -type f -size 0 -exec ls -l {} \;</code></pre></blockquote><p>#####3. sz下载，rz上传</p><p>rz，sz是<code>Linux/Unix</code>同<code>Windows</code>进行<code>ZModem</code>文件传输的命令行工具。<br>优点就是不用再开一个sftp工具登录上去上传下载文件。</p><p>sz：将选定的文件发送（send）到本地机器<br>rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器</p><p>安装命令：</p><blockquote><p>yum install lrzsz</p></blockquote><p>从服务端发送文件到客户端：</p><blockquote><p>sz filename</p></blockquote><p>从客户端上传文件到服务端：</p><p>rz</p><p>在弹出的框中选择文件，上传文件的用户和组是当前登录的用户</p><p><code>SecureCRT</code>设置默认路径：</p><p>Options -&gt; Session Options -&gt; Terminal -&gt; Xmodem/Zmodem -&gt;Directories</p><p><code>Xshell</code>设置默认路径：</p><p>右键会话 -&gt; 属性 -&gt; ZMODEM -&gt; 接收文件夹</p><h3 id="3-mv命令"><a href="#3-mv命令" class="headerlink" title="3. mv命令"></a>3. mv命令</h3><p>mv 命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>语法：</p><blockquote><p>linux</p><pre class=" language-linux"><code class="language-linux">mv [options] source destmv [options] source... directory</code></pre></blockquote><p>参数说明：</p><ul><li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li><li>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;</li></ul><p>参数设置和运行结果：</p><table><thead><tr><th align="left">命令格式</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">mv 文件名 文件名</td><td align="left">将源文件名改为目标文件名</td></tr><tr><td align="left">mv 文件名 目录名</td><td align="left">将文件移动到目标目录</td></tr><tr><td align="left">mv 目录名 目录名</td><td align="left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td align="left">mv 目录名 文件名</td><td align="left">出错</td></tr></tbody></table><p>命令案例：</p><blockquote><p>mv a b //将文件a更名为b</p><p>mv info/ logs //将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p><p>mv /home/img/* . //将/home/img下的所有文件和目录移到当前目录下</p></blockquote><p>注意：</p><blockquote><p>mv /home/a.txt /home/b.txt //目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名。</p><p>//目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动。</p><p>mv /home/a.txt /home/test/ 或者 mv /home/a.txt /home/test</p><p>mv /home/a.txt /home/test/b.txt //目标目录与原目录一致, 指定了新文件名，效果就是：移动 + 重命名。</p></blockquote><h3 id="4-Linux开发工具"><a href="#4-Linux开发工具" class="headerlink" title="4. Linux开发工具"></a>4. Linux开发工具</h3><p>Linux已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在Linux的帮助下，技术的变革速度超出了人们的想象，Linux开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习Linux开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着Linux的发展，大量适用于Linux的开发工具也不断成熟。</p><p>容器</p><p> 放眼现实，现在已经是容器的时代了。容器既极其容易部署，又可以方便地构建开发环境。如果针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。</p><p>版本控制工具</p><p>如果正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。</p><p>文本编辑器</p><p>如果没有文本编辑器，在Linux上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。</p><p>集成开发环境</p><p>集成开发环境(Integrated Developmemt Envimnment，<a href="https://baike.baidu.com/item/IDE/8232086" target="_blank" rel="noopener">IDE</a>) 是包含一整套全面的工具、可以实现一站式功能的开发环境。</p><p>文本比较工具</p><p>有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本(例如有一个经过编译，而另一个没有)。这种情况下，肯定不想要凭借肉眼来找出差异，而是想要使用像<a href="https://baike.baidu.com/item/Med/8237994" target="_blank" rel="noopener">Med</a>这样的工具。 </p><p>如果有错的话，请给我留言，我会及时更新,谢谢合作……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 开源代码 </tag>
            
            <tag> auto </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么写文章</title>
      <link href="/posts/1513.html"/>
      <url>/posts/1513.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 有时候自己写<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>文章的时候,老是记不住<a href="https://baike.baidu.com/item/markdown?fr=aladdin" target="_blank" rel="noopener">Markdown</a>文档的语法或者怎么新建文章，还有<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter </a>选项怎么去用，所以呢！我就准备自己写一篇文章去记录这些，以免每次写文章都得去百度一大堆东西,本文章不定期更新….</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="新建文章模板修改"><a href="#新建文章模板修改" class="headerlink" title="新建文章模板修改"></a>新建文章模板修改</h3><p> 首先为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class=" language-json"><code class="language-json">title<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span>date<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> date <span class="token punctuation">}</span><span class="token punctuation">}</span>author<span class="token operator">:</span> img<span class="token operator">:</span> coverImg<span class="token operator">:</span> top<span class="token operator">:</span> <span class="token boolean">false</span>cover<span class="token operator">:</span> <span class="token boolean">false</span>toc<span class="token operator">:</span> <span class="token boolean">true</span>mathjax<span class="token operator">:</span> <span class="token boolean">false</span>password<span class="token operator">:</span>summary<span class="token operator">:</span>tags<span class="token operator">:</span>categories<span class="token operator">:</span>---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了</p><h3 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h3><h4 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h4><p><code>Front-matte1r</code>选项中的所有内容均为非必填的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><p><img src="./1.gif" data-original="https://cdn.jsdelivr.net/gh/baifeng66/picgophots/images/fm1.png" alt=""></p><p><img src="./1.gif" data-original="https://cdn.jsdelivr.net/gh/baifeng66/picgophots/images/fm2.png" alt=""></p><blockquote><p>注意:</p><ol><li>如果<code>img</code>属性不填写的话，文章特色图会根据文章标题的<code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别<code>id</code>是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code>加密的 <code>password</code> 的值，还需要在主题的<code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="https://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 <code>front-matter</code> 中指定 <code>reprintPolicy</code>来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 Front-matter 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-yml"><code class="language-yml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yml"><code class="language-yml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="一、参考文档"><a href="#一、参考文档" class="headerlink" title="一、参考文档"></a>一、参考文档</h4><blockquote><p><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown 中文版语法说明</a></p><p><a href="https://blog.csdn.net/u014061630/article/details/81359144" target="_blank" rel="noopener">Markdown语法图文全面详解(10分钟学会)</a></p><p><a href="https://blog.csdn.net/sanallen/article/details/92081911" target="_blank" rel="noopener">Markdown文档编写指南</a></p><p><a href="https://sunhwee.gitee.io/posts/a927e90e.html#toc-heading-1" target="_blank" rel="noopener">Markdown Emoji表情语法速查表</a></p><p><a href="https://sunhwee.gitee.io/posts/7e1e06e9.html" target="_blank" rel="noopener">Markdown 插入图片或者视频</a></p></blockquote><h4 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h4><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><p>   注：# 后面保持空格</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># h1</span><span class="token comment" spellcheck="true">## h2</span><span class="token comment" spellcheck="true">### h3</span><span class="token comment" spellcheck="true">#### h4</span><span class="token comment" spellcheck="true">##### h5</span><span class="token comment" spellcheck="true">###### h6</span></code></pre><h5 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h5><p>Markdown划分段落非常简单，就是在段落前后保留一个空行即可，例如：</p><pre><code>这是第一个段落内容这是第二个段落内容</code></pre><p>效果如下：</p><p>这是第一个段落内容</p><p>这是第二个段落内容</p><h5 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h5><p>如果我们需要对一段内容进行强调显示时，Markdown提供了一个特殊符号&gt;(&gt;和内容之前需要空一个空格)用于段落区块引用：</p><pre><code>&gt;这是一段引用段落，将会被高亮显示</code></pre><p>效果如下：</p><blockquote><p>这是一段引用段落，将会被高亮显示</p></blockquote><p>Markdown支持同时强调引用多个段落，可以按照如下方式书写</p><pre><code>&gt; 这是一段引用段落，将会被高亮显示&gt;&gt; 这也是一段引用段落，也会被高亮显示</code></pre><blockquote><p>这是一段引用段落，将会被高亮显示</p><p>这也是一段引用段落，也会被高亮显示</p></blockquote><h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><pre><code>[超链接显示文字](http://www.baidu.com "超链接title")</code></pre><p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="超链接title">超链接显示文字</a></p><p>提示：超链接title为浮动提示文字，一般情况可以不填写</p><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><pre><code>![百度logo](https://www.baidu.com/img/bd_logo1.png?where=super)</code></pre><p><img src="./1.gif" data-original="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度logo"></p><blockquote><p>图片和超链接的唯一区别就是在最前方添加一个感叹号</p></blockquote><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表使用<em>、+、-标识，但是一般使用</em>来标识无序列表</p><p>单级列表从最左开始(适用于无序列表)</p><pre><code>* 无序列表项* 无序列表项* 无序列表项</code></pre><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项</li></ul><p>Markdown支持多级列表嵌套，但是建议一般不使用超过两级列表，另外建议两级列表从缩进3个空格开始(适用于无序列表)，如下所示:</p><pre><code>   * 无序列表项      * 第二层列表项      * 第二层列表项   * 无序列表项   * 无序列表项</code></pre><ul><li>无序列表项<ul><li>第二层列表项</li><li>第二层列表项</li></ul></li><li>无序列表项</li><li>无序列表项</li></ul><p>有序列表</p><p>有序列表使用<font color="red">数字 </font>.标识</p><pre><code>1. 有序列表项12. 有序列表项23. 有序列表项3</code></pre><ol><li>有序列表项1</li><li>有序列表项2</li><li>有序列表项3</li></ol><pre><code>   1. 有序列表项1      1. 有序列表项11      2. 有序列表项12   2. 有序列表项3</code></pre><ol><li>有序列表项1<ol><li>有序列表项11</li><li>有序列表项12</li></ol></li><li>有序列表项3</li></ol><h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><pre><code>***---</code></pre><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><pre><code>*这里是文字*_这里是文字_**这里是文字*****这里是文字***~~这里是文字~~</code></pre><p><em>这里是文字</em></p><p><em>这里是文字</em></p><p><strong>这里是文字</strong></p><p><strong><em>这里是文字</em></strong></p><p><del>这里是文字</del></p><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><h6 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h6><p>使用单个反引号进行包裹行内代码，例如 <code>var x = 10</code></p><h6 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h6><p>可以通过三个反引号将代码包裹起来，反引号单独占一行，多一行单引号后面可以需要添加编程语言，详细的编程语言见<a href="https://pygments.org/languages/" target="_blank" rel="noopener">http://pygments.org/languages/</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span>func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><pre><code>| 表头 | 表头 | 表头 || ---- | ---- | ---- || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 |</code></pre><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr></tbody></table><p>如果有错的话，请给我留言，我会及时更新,谢谢合作…… </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> VS code </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做自己</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>不是每个人都会喜欢你，</p><p>有人羡慕你，也有人讨厌你，</p><p>有人嫉妒你，也有人看不起你。</p><p><a href="https://www.yangruolan.com/tags-22.html" target="_blank" rel="noopener">生活</a>就是这样，</p><p>你所做的一切不能让每个人都满意，</p><p>不要为了讨好别人而丢失自己的本性，</p><p>因为每个人都有原则和自尊!</p><p>别人嘴里的你，不是真实的你。</p><p>一样的眼睛，不一样的看法。</p><p>一样的嘴巴，不一样的说法。</p><p>一样的心，不一样的想法。</p><p><a href="https://www.yangruolan.com/tags-9.html" target="_blank" rel="noopener">人生</a>的路，要活出自我，活出自信。</p><p>我很喜欢这段话：</p><p>“钱”离开人，废纸一张；</p><p>人离开“钱”，废物一个。</p><p>鹰，不需鼓掌，也在飞翔。</p><p>小草，没人心疼，也在成长。</p><p>做事不需人人都<a href="https://www.yangruolan.com/tags-168.html" target="_blank" rel="noopener">理解</a>，只需尽心尽力，</p><p>坚持，注定有<a href="https://www.yangruolan.com/tags-17.html" target="_blank" rel="noopener">孤独</a>彷徨，质疑嘲笑，也都无妨。</p><p>做最真实最漂亮的自己，</p><p>依心而行，无憾今生！！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 自己 </tag>
            
            <tag> 坚持 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dream</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>不是每个人都应该像我这样去建造一座水晶大教堂，但是每个人都应该拥有自己的梦想，设计自己的梦想，追求自己的梦想，实现自己的梦想。梦想是生命的灵魂，是心灵的灯塔，是引导人走向成功的信仰。有了崇高的梦想，只要矢志不渝地追求，梦想就会成为现实，奋斗就会变成壮举，生命就会创造奇迹。——罗伯·舒乐</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 梦想 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
